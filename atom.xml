<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>周建川的随想录</title>
  
  <subtitle>因为懂得，所以慈悲。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jantc.cn/"/>
  <updated>2020-03-23T09:10:50.359Z</updated>
  <id>http://jantc.cn/</id>
  
  <author>
    <name>Jant</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM垃圾回收就是这么简单</title>
    <link href="http://jantc.cn/2018/09/04/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%B0%B1%E6%98%AF%E8%BF%99%E4%B9%88%E7%AE%80%E5%8D%95/"/>
    <id>http://jantc.cn/2018/09/04/JVM垃圾回收就是这么简单/</id>
    <published>2018-09-04T03:03:23.000Z</published>
    <updated>2020-03-23T09:10:50.359Z</updated>
    
    <content type="html"><![CDATA[<p>本文导火索</p><p>当需要排查各种 内存溢出问题、当垃圾收集称为系统达到更高并发的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节。</p><a id="more"></a><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><h4 id="本节常见面试题"><a href="#本节常见面试题" class="headerlink" title="本节常见面试题"></a>本节常见面试题</h4><p><img src="http://ooes75dyq.bkt.clouddn.com/jvm01.jpg" alt><br>问题答案在文中都有提到</p><ul><li>如何判断对象是否死亡（两种方法）。</li><li>简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。</li><li>如何判断一个常量是废弃常量</li><li>如何判断一个类是无用的类</li><li>垃圾收集有哪些算法，各自的特点？</li><li>HotSpot为什么要分为新生代和老年代？</li><li>常见的垃圾回收器有那些？</li><li>介绍一下CMS,G1收集器。</li><li>Minor Gc和Full GC 有什么不同呢？</li></ul><h3 id="揭开JVM内存分配与回收的神秘面纱"><a href="#揭开JVM内存分配与回收的神秘面纱" class="headerlink" title="揭开JVM内存分配与回收的神秘面纱"></a>揭开JVM内存分配与回收的神秘面纱</h3><p>Java 的自动内存管理主要是针对对象内存的回收和对象内存的分配。同时，Java 自动内存管理最核心的功能是<strong>堆</strong>内存中对象的分配与回收。</p><p><strong>JDK1.8之前的堆内存示意图：</strong><br><img src="http://ooes75dyq.bkt.clouddn.com/jvm02.jpg" alt="堆空间大小"></p><p>从上图可以看出堆内存的分为新生代、老年代和永久代。新生代又被进一步分为：Eden 区＋Survior1 区＋Survior2 区。值得注意的是，在 JDK 1.8中移除整个永久代，取而代之的是一个叫元空间（Metaspace）的区域（永久代使用的是JVM的堆内存空间，而元空间使用的是物理内存，直接受到本机的物理内存限制）。</p><p><img src="http://ooes75dyq.bkt.clouddn.com/jvm03.jpg" alt="分配策略"></p><h4 id="对象优先在eden区分配"><a href="#对象优先在eden区分配" class="headerlink" title="对象优先在eden区分配"></a>对象优先在eden区分配</h4><p>目前主流的垃圾收集器都会采用分代回收算法，因此需要将堆内存分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p><p>大多数情况下，对象在新生代中 eden 区分配。当 eden 区没有足够空间进行分配时，虚拟机将发起一次Minor GC.下面我们来进行实际测试以下。</p><p>在测试之前我们先来看看<strong> Minor Gc和Full GC 有什么不同呢？</strong></p><ul><li><strong>新生代GC（Minor GC）</strong>:指发生新生代的的垃圾收集动作，Minor GC非常频繁，回收速度一般也比较快。</li><li><strong>老年代GC（Major GC/Full GC）</strong>:指发生在老年代的GC，出现了Major GC经常会伴随至少一次的Minor GC（并非绝对），Major GC的速度一般会比Minor GC的慢10倍以上。</li></ul><p><strong>测试：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] allocation1, allocation2;</span><br><span class="line">        allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">30900</span>*<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">//allocation2 = new byte[900*1024];</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过以下方式运行：</p><p>添加的参数：-XX:+PrintGCDetails </p><p>运行完毕后我们可以看出eden区内存几乎已经被分配完全（即使程序什么也不做，新生代也会使用2000多k内存）。假如我们再为allocation2分配内存会出现什么情况呢？</p><blockquote><p>allocation2 = new byte[900*1024];</p></blockquote><p><img src="http://ooes75dyq.bkt.clouddn.com/jvm04.jpg" alt="执行结果"><br><strong>简单解释一下为什么会出现这种情况：</strong> 因为给allocation2分配内存的时候eden区内存几乎已经被分配完了，我们刚刚讲了当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC.GC期间虚拟机又发现allocation1无法存入Survior空间，所以只好通过 分配担保机制 把新生代的对象提前转移到老年代中去，老年代上的空间足够存放allocation1，所以不会出现Full GC。执行Minor GC后，后面分配的对象如果能够存在eden区的话，还是会在eden区分配内存。可以执行如下代码验证：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] allocation1, allocation2,allocation3,allocation4,allocation5;</span><br><span class="line">        allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">32000</span>*<span class="number">1024</span>];</span><br><span class="line">        allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>*<span class="number">1024</span>];</span><br><span class="line">        allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>*<span class="number">1024</span>];</span><br><span class="line">        allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>*<span class="number">1024</span>];</span><br><span class="line">        allocation5 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>*<span class="number">1024</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h4><p>大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。<br><strong>为什么要这样呢？</strong><br>为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。</p><h4 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h4><p>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别那些对象应放在新生代，那些对象应放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。</p><p>如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为1.对象在 Survivor 中每熬过一次 MinorGC,年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。</p><h4 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h4><p>为了更好的适应不同程序的内存情况，虚拟机不是永远要求对象年龄必须达到了某个值才能进入老年代，如果 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需达到要求的年龄。</p><h4 id="对象已经死亡？"><a href="#对象已经死亡？" class="headerlink" title="对象已经死亡？"></a>对象已经死亡？</h4><p>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使用的。</p><p><strong>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。</strong> 所谓对象之间的相互引用问题，如下面代码所示：除了对象objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为0，于是引用计数算法无法通知 GC 回收器回收他们。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGc</span> </span>&#123;</span><br><span class="line">    Object instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReferenceCountingGc objA = <span class="keyword">new</span> ReferenceCountingGc();</span><br><span class="line">        ReferenceCountingGc objB = <span class="keyword">new</span> ReferenceCountingGc();</span><br><span class="line">        objA.instance = objB;</span><br><span class="line">        objB.instance = objA;</span><br><span class="line">        objA = <span class="keyword">null</span>;</span><br><span class="line">        objB = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>这个算法的基本思想就是通过一系列的称为“<strong>GC Roots</strong>” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。<br><img src="http://ooes75dyq.bkt.clouddn.com/jvm05.jpg" alt="GC Roots"></p><h4 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h4><p>无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。</p><p>JDK1.2之前，Java中引用的定义很传统：如果reference类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。</p><p>JDK1.2以后，Java对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）</p><h5 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h5><p>以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于<strong>必不可少的生活用品</strong>，垃圾回收器绝不会回收它。当内存空 间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p><h5 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h5><p>如果一个对象只具有软引用，那就类似于<strong>可有可物的生活用品</strong>。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p><p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA虚拟机就会把这个软引用加入到与之关联的引用队列中。</p><h5 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h5><p>如果一个对象只具有弱引用，那就类似于<strong>可有可物的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p><p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p><h5 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h5><p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。<br><strong>虚引用主要用来跟踪对象被垃圾回收的活动。</strong><br><strong>虚引用与软引用和弱引用的一个区别在于：</strong> 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃 圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是 否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。<br>特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为<strong>软引用可以加速JVM对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生。</strong></p><h4 id="不可达的对象并非“非死不可”"><a href="#不可达的对象并非“非死不可”" class="headerlink" title="不可达的对象并非“非死不可”"></a>不可达的对象并非“非死不可”</h4><p>即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。</p><p>被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。</p><h4 id="如何判断废弃常量"><a href="#如何判断废弃常量" class="headerlink" title="如何判断废弃常量"></a>如何判断废弃常量</h4><p>运行时常量池主要回收的是废弃的常量。那么，我们如何判断一个常量是废弃常量呢？</p><p>假如在常量池中存在字符串 “abc”，如果当前没有任何String对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池。</p><p>注意：我们在 可能是把Java内存区域讲的最清楚的一篇文章 也讲了JDK1.7及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。</p><h4 id="如何判断一个类是无用的类"><a href="#如何判断一个类是无用的类" class="headerlink" title="如何判断一个类是无用的类"></a>如何判断一个类是无用的类</h4><p>方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？</p><p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面3个条件才能算是 “无用的类” ：</p><ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li><li>加载该类的 ClassLoader 已经被回收。</li><li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><p>虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。</p><h4 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h4><p><img src="http://ooes75dyq.bkt.clouddn.com/jvm06.jpg" alt="垃圾收集算法"></p><h5 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h5><p>算法分为“标记”和“清除”阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。它是最基础的收集算法，效率也很高，但是会带来两个明显的问题：</p><ul><li>效率问题</li><li>空间问题（标记清楚会产生大量不连续的碎片）</li></ul><h5 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h5><p>为了解决效率问题，“复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p><h5 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h5><p>根据老年代的特点特出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一段移动，然后直接清理掉端边界以外的内存。<br><img src="http://ooes75dyq.bkt.clouddn.com/jvm07.jpg" alt="GC 算法"></p><h5 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h5><p>当前虚拟机的垃圾手机都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将java堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。<br><strong>比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清楚”或“标记-整理”算法进行垃圾收集。</strong></p><p><strong>延伸面试问题：</strong> HotSpot为什么要分为新生代和老年代？</p><p>根据上面的对分代收集算法的介绍回答。</p><h4 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h4><p><img src="http://ooes75dyq.bkt.clouddn.com/jvm08.jpg" alt="垃圾回收器"></p><p><strong>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</strong></p><p>虽然我们对各个收集器进行比较，但并非了挑选出一个最好的收集器。因为知道现在位置还没有最好的垃圾收集器出现，更加没有万能的垃圾收集器，<strong>我们能做的就是根据具体应用场景选择适合自己的垃圾收集器</strong>。试想一下：如果有一种四海之内、任何场景下都适用的完美收集器存在，那么我们的HotSpot虚拟机就不会实现那么多不同的垃圾收集器了。</p><h5 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h5><p>Serial（串行）收集器收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 “<strong>单线程</strong>” 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ “<strong>Stop The World</strong>“ ），直到它收集结束。</p><p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></p><p>虚拟机的设计者们当然知道Stop The World带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。</p><p>但是Serial收集器有没有优于其他垃圾收集器的地方呢？当然有，它<strong>简单而高效（与其他收集器的单线程相比）</strong>。Serial收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial收集器对于运行在Client模式下的虚拟机来说是个不错的选择。</p><h5 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h5><p><strong>ParNew收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和Serial收集器完全一样。</strong></p><p><strong>新生代采用复制算法，老年代采用标记-整理算法。 </strong></p><p>它是许多运行在Server模式下的虚拟机的首要选择，除了Serial收集器外，只有它能与CMS收集器（真正意义上的并发收集器，后面会介绍到）配合工作。</p><p><strong>并行和并发概念补充：</strong></p><ul><li><strong>并行</strong>（Parallel） ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态</li><li><strong>并发</strong>（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个CPU上。</li></ul><h5 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h5><p>Parallel Scavenge 收集器类似于ParNew 收集器。 那么它有什么<strong>特别之处</strong>呢？</p><blockquote><p>-XX:+UseParallelGC<br> 使用Parallel收集器+ 老年代串行</p></blockquote><blockquote><p>-XX:+UseParallelOldGC<br>使用Parallel收集器+ 老年代并行</p></blockquote><p><strong>Parallel Scavenge收集器关注点是吞吐量（高效率的利用CPU）。CMS等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值</strong>。 Parallel Scavenge收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解的话，手工优化存在的话可以选择把内存管理优化交给虚拟机去完成也是一个不错的选择。</p><p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></p><h5 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title=".Serial Old收集器"></a>.Serial Old收集器</h5><p><strong>Serial收集器的老年代版本</strong>，它同样是一个单线程收集器。它主要有两大用途：一种用途是在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用，另一种用途是作为CMS收集器的后备方案。</p><h5 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h5><p><strong>Parallel Scavenge收集器的老年代版本</strong>。使用多线程和“标记-整理”算法。在注重吞吐量以及CPU资源的场合，都可以优先考虑 Parallel Scavenge收集器和Parallel Old收集器。</p><h5 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h5><p><strong>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它而非常符合在注重用户体验的应用上使用。</strong></p><p><strong>CMS（Concurrent Mark Sweep）收集器是HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</strong></p><p>从名字中的<strong>Mark Sweep</strong>这两个词可以看出，CMS收集器是一种 “<strong>标记-清除</strong>”算法实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：</p><ul><li><strong>初始标记</strong>： 暂停所有的其他线程，并记录下直接与root相连的对象，速度很快 ；</li><li><strong>并发标记</strong>： 同时开启GC和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以GC线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li><li><strong>重新标记</strong>： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li><li><strong>并发清除</strong>： 开启用户线程，同时GC线程开始对为标记的区域做清扫。</li></ul><p>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：<strong>并发收集、低停顿</strong>。但是它有下面三个明显的缺点：</p><ul><li><strong>对CPU资源敏感</strong>；</li><li><strong>无法处理浮动垃圾</strong>；</li><li><strong>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生</strong>。</li></ul><h5 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h5><p><strong>G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征.</strong><br>被视为JDK1.7中HotSpot虚拟机的一个重要进化特征。它具备一下特点：</p><ul><li><strong>并行与并发</strong>：G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。</li><li><strong>分代收集</strong>：虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。</li><li><strong>空间整合</strong>：与CMS的“标记–清理”算法不同，G1从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。</li><li><strong>可预测的停顿</strong>：这是G1相对于CMS的另一个大优势，降低停顿时间是G1 和 CMS 共同的关注点，但G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内。</li></ul><p>G1收集器的运作大致分为以下几个步骤：</p><ul><li><strong>初始标记</strong></li><li><strong>并发标记</strong></li><li><strong>最终标记</strong></li><li><strong>筛选回收</strong><br><strong>G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region(这也就是它的名字Garbage-First的由来)</strong>。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了GF收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</li></ul><p><strong>本文转载: <a href="https://www.zhihu.com/people/kou-shuang-1/activities" target="_blank" rel="noopener">Snailclimb</a> </strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文导火索&lt;/p&gt;
&lt;p&gt;当需要排查各种 内存溢出问题、当垃圾收集称为系统达到更高并发的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://jantc.cn/categories/java/"/>
    
    
      <category term="JVM垃圾回收" scheme="http://jantc.cn/tags/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
  </entry>
  
  <entry>
    <title>Spring中控制两个Bean的初始化顺序</title>
    <link href="http://jantc.cn/2018/09/03/Spring%E4%B8%AD%E6%8E%A7%E5%88%B6%E4%B8%A4%E4%B8%AABean%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F/"/>
    <id>http://jantc.cn/2018/09/03/Spring中控制两个Bean的初始化顺序/</id>
    <published>2018-09-03T02:46:02.000Z</published>
    <updated>2020-03-23T09:10:50.367Z</updated>
    
    <content type="html"><![CDATA[<p>开发过程中有这样一个场景，2个 bean 初始化逻辑中有依赖关系，需要控制二者的初始化顺序。实现方式可以有多种，本文结合目前对 Spring 的理解，尝试列出几种思路。</p><a id="more"></a><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>假设A，B两个 bean 都需要在初始化的时候从本地磁盘读取文件，其中B加载的文件，依赖A中加载的全局配置文件中配置的路径，所以需要A先于B初始化，此外A中的配置改变后也需要触发B的重新加载逻辑，所以A，B需要注入彼此。<br>对于下面的模型，问题简化为：我们需要initA()先于initB()得到执行。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"A construct"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        initA();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"A init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span>  </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"B construct"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        initB();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"B init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="方案一：立Flag"><a href="#方案一：立Flag" class="headerlink" title="方案一：立Flag"></a>方案一：立Flag</h3><p>我们可以在业务层自己控制A，B的初始化顺序，在A中设置一个“是否初始化的”标记，B初始化前检测A是否得以初始化，如果没有则调用A的初始化方法，所谓的check-and-act。对于上述模型，实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> initialized;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"A construct"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        initA();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInitialized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> initialized;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isInitialized()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"A init"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        initialized = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"B construct"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        initB();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!a.isInitialized()) &#123;</span><br><span class="line">            a.initA();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"B init"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>执行结果:<br>A construct<br>B construct<br>A init<br>B init</p></blockquote><p>这种立flag的方法好处是可以做到lazy initialization，但是如果类似逻辑很多的话代码中到处充斥着类似代码，不优雅，所以考虑是否框架本身就可以满足我们的需要。</p><h3 id="方案二：使用DependsOn"><a href="#方案二：使用DependsOn" class="headerlink" title="方案二：使用DependsOn"></a>方案二：使用DependsOn</h3><p>Spring 中的 DependsOn 注解可以保证被依赖的bean先于当前bean被容器创建，但是如果不理解Spring中bean加载过程会对 DependsOn 有误解，自己也确实踩过坑。对于上述模型，如果在B上加上注解@DependsOn({“a”})，得到的执行结果是：</p><blockquote><p>A construct<br>B construct<br>B init<br>A init</p></blockquote><p>在这里问题的关键是：bean属性的注入是在初始化方法调用之前<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码位置：AbstractAutowireCapableBeanFactory.doCreateBean</span></span><br><span class="line"><span class="comment">// 填充 bean 的各个属性，包括依赖注入</span></span><br><span class="line">populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line"><span class="keyword">if</span> (exposedObject != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 调用初始化方法，如果是 InitializingBean 则先调用 afterPropertiesSet 然后调用自定义的init-method 方法</span></span><br><span class="line">    exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结合本例，发生的实际情况是，因为出现了循环依赖，A依赖B，加载B，B依赖A，所以得到了一个提前暴露的A，然后调用B的初始化方法，接着回到A的初始化方法。具体源码分析过程如下：<br>ApplicationContext 在 refresh 过程中的最后会加载所有的 no-lazy 单例。<br><img src="http://ooes75dyq.bkt.clouddn.com/spring01.jpg" alt="加载顺序"><br>本例中，先加载的bean A，最终通过无参构造器构造，然后，继续属性填充（populateBean），发现需要注入 bean B。所以转而加载 bean B（递归调用 getBean()）。此时发现 bean B 需要 DependsOn(“a”)，在保存依赖关系（为了防止循环 depends）后，调用 getBean(“a”)，此时会得到提前暴露的 bean A ，所以继续 B 的加载，流程为： 初始化策略构造实例 -&gt; 属性填充（同样会注入提前暴露的 bean A ） -&gt; 调用初始化方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码位置：AbstractBeanFactory.doGetBean</span></span><br><span class="line"><span class="comment">// Guarantee initialization of beans that the current bean depends on. 实例化依赖的 bean</span></span><br><span class="line">        String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">        <span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(),</span><br><span class="line">                            beanName, <span class="string">"Circular depends-on relationship between '"</span></span><br><span class="line">                            + beanName + <span class="string">"' and '"</span> + dep + <span class="string">"'"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                registerDependentBean(dep, beanName); <span class="comment">// 缓存 bean 依赖的关系</span></span><br><span class="line">                getBean(dep);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p>得到提前暴露的 bean A的过程为：<br><img src="http://ooes75dyq.bkt.clouddn.com/spring02.png" alt="源码"></p><p>此时此刻，bean A 的属性注入完成了， 返回到调用初始化方法，所以表现的行为是：构造A -&gt; 构造B -&gt; B初始化 -&gt; A初始化。<br>DependsOn只是保证的被依赖的bean先于当前bean被实例化，被创建，所以如果要采用这种方式实现bean初始化顺序的控制，那么可以把初始化逻辑放在构造函数中，但是复杂耗时的逻辑放在构造器中是不合适的，会影响系统启动速度。</p><h3 id="方案三：容器加载bean之前"><a href="#方案三：容器加载bean之前" class="headerlink" title="方案三：容器加载bean之前"></a>方案三：容器加载bean之前</h3><p>Spring 框架中很多地方都为我们提供了扩展点，很好的体现了开闭原则（OCP）。其中 BeanFactoryPostProcessor 可以允许我们在容器加载任何bean之前修改应用上下文中的BeanDefinition（从XML配置文件或者配置类中解析得到的bean信息，用于后续实例化bean）。<br>在本例中，就可以把A的初始化逻辑放在一个 BeanFactoryPostProcessor 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ABeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory configurableListableBeanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        A.initA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行效果：</p><blockquote><p>A init<br>A construct<br>B construct<br>B init</p></blockquote><p>这种方式把A中的初始化逻辑放到了加载bean之前，很适合加载系统全局配置，但是这种方式中初始化逻辑不能依赖bean的状态。</p><h3 id="方案四：事件监听器的有序性"><a href="#方案四：事件监听器的有序性" class="headerlink" title="方案四：事件监听器的有序性"></a>方案四：事件监听器的有序性</h3><p>Spring 中的 Ordered 也是一个很重要的组件，很多逻辑中都会判断对象是否实现了 Ordered 接口，如果实现了就会先进行排序操作。比如在事件发布的时候，对获取到的 ApplicationListener 会先进行排序。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码位置：AbstractApplicationEventMulticaster.ListenerRetriever.getApplicationListeners()</span></span><br><span class="line"><span class="keyword">public</span> Collection&lt;ApplicationListener&lt;?&gt;&gt; getApplicationListeners() &#123;</span><br><span class="line">        LinkedList&lt;ApplicationListener&lt;?&gt;&gt; allListeners = <span class="keyword">new</span> LinkedList&lt;ApplicationListener&lt;?&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : <span class="keyword">this</span>.applicationListeners) &#123;</span><br><span class="line">            allListeners.add(listener);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.applicationListenerBeans.isEmpty()) &#123;</span><br><span class="line">            BeanFactory beanFactory = getBeanFactory();</span><br><span class="line">            <span class="keyword">for</span> (String listenerBeanName : <span class="keyword">this</span>.applicationListenerBeans) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ApplicationListener&lt;?&gt; listener = beanFactory.getBean(listenerBeanName, ApplicationListener<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>.preFiltered || !allListeners.contains(listener)) &#123;</span><br><span class="line">                        allListeners.add(listener);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">                    <span class="comment">// Singleton listener instance (without backing bean definition) disappeared -</span></span><br><span class="line">                    <span class="comment">// probably in the middle of the destruction phase</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        AnnotationAwareOrderComparator.sort(allListeners); <span class="comment">// 排序</span></span><br><span class="line">        <span class="keyword">return</span> allListeners;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>所以可以利用事件监听器在处理事件时的有序性，在应用上下文 refresh 完成后，分别实现A，B中对应的初始化逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationListenerA</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ApplicationContextEvent</span>&gt;, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationContextEvent event)</span> </span>&#123;</span><br><span class="line">        initA();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Ordered.HIGHEST_PRECEDENCE; <span class="comment">// 比 ApplicationListenerB 优先级高</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"A init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationListenerB</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ApplicationContextEvent</span>&gt;, <span class="title">Ordered</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationContextEvent event)</span> </span>&#123;</span><br><span class="line">        initB();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Ordered.HIGHEST_PRECEDENCE -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"B init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行效果：</p><blockquote><p>A construct<br>B construct<br>A init<br>B init</p></blockquote><p>这种方式就是站在事件响应的角度，上下文加载完成后，先实现A逻辑，然后实现B逻辑。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在平时的开发中使用的可能都是一个语言，一个框架的冰山一角，随着对语言，对框架的不断深入，你会发现更多的可能。本文只是基于目前对于 Spring 框架的理解做出的尝试，解决一个问题可能有多种方式，其中必然存在权衡选择，取决于对业务对技术的理解。</p><p>本文出处：<a href="https://sq.163yun.com/blog/article/191350999869239296" target="_blank" rel="noopener">https://sq.163yun.com/blog/article/191350999869239296</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开发过程中有这样一个场景，2个 bean 初始化逻辑中有依赖关系，需要控制二者的初始化顺序。实现方式可以有多种，本文结合目前对 Spring 的理解，尝试列出几种思路。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://jantc.cn/categories/java/"/>
    
    
      <category term="Spring" scheme="http://jantc.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>单例设计模式</title>
    <link href="http://jantc.cn/2018/08/09/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://jantc.cn/2018/08/09/单例设计模式/</id>
    <published>2018-08-09T05:39:02.000Z</published>
    <updated>2020-03-23T09:10:50.370Z</updated>
    
    <content type="html"><![CDATA[<p>单例模式比较常见，本文对单例模式的写法进行一个总结。</p><a id="more"></a><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//懒汉式单例类.在第一次调用的时候实例化自己   </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance=<span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            instance=<span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>懒汉式顾名思义，会延迟加载，在第一次使用该单例的时候才会实例化对象出来，第一次调用时要做初始化，如果要做的工作比较多，性能上会有些延迟.但是存在一个问题就是线程不安全的。例如：当两个线程同时运行到判断instance是否为空的if语句，并且instance确实没有创建好时，那么两个线程都会创建一个实例。</p></blockquote><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    <span class="comment">//静态工厂方法   </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>饿汉式本身就是线程安全的，饿汉式在类创建的同时就实例化一个静态对象出来，不管之后会不会使用这个单例，都会占据一定的内存，但是相应的，在第一次调用时速度也会更快，因为其资源已经初始化完成。缺点：没有lazy loading的效果，从而降低内存的使用率</p></blockquote><h3 id="Double-Check"><a href="#Double-Check" class="headerlink" title="Double Check"></a>Double Check</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>注意：假设没有关键字volatile的情况下，两个线程A、B，都是第一次调用该单例方法，线程A先执行instance = new Instance()，该构造方法是一个非原子操作，编译后生成多条字节码指令，由于JAVA的指令重排序，可能会先执行instance的赋值操作，该操作实际只是在内存中开辟一片存储对象的区域后直接返回内存的引用，之后instance便不为空了，但是实际的初始化操作却还没有执行，如果就在此时线程B进入，就会看到一个不为空的但是不完整（没有完成初始化）的Instance对象，所以需要加入volatile关键字，禁止指令重排序优化，从而安全的实现单例。</li></ul></blockquote><blockquote><ul><li>禁止指令重排优化这条语义直到jdk1.5以后才能正确工作。此前的JDK中即使将变量声明为volatile也无法完全避免重排序所导致的问题。所以，在jdk1.5版本前，双重检查锁形式的单例模式是无法保证线程安全的。</li></ul></blockquote><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>由于类级内部类相当于其外部类的成员，只有在第一次被使用的时候才会被装载，所以引出了这种写法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton instance=<span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>优点：达到了lazy loading的效果，即按需创建实例</p></blockquote><h3 id="枚举写法"><a href="#枚举写法" class="headerlink" title="枚举写法"></a>枚举写法</h3><p>这是Effective Java推崇的一种优雅的写法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>枚举写法比较优雅但是不是任何场景都适用，虽然Effective Java中推荐使用，但是在Android平台上却是不被推荐的。在这篇Android Training中明确指出：</p><ul><li>Enums often require more than twice as much memory as static constants. You should strictly avoid using enums on Android.</li></ul></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>不管采取哪种方式，单例模式必不可忘的三大要素:</p><blockquote><ul><li>线程安全</li><li>延迟加载</li><li>序列化与反序列化安全</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单例模式比较常见，本文对单例模式的写法进行一个总结。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://jantc.cn/categories/java/"/>
    
    
      <category term="设计模式" scheme="http://jantc.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>分布式2PC与3PC的区别</title>
    <link href="http://jantc.cn/2018/08/07/%E5%88%86%E5%B8%83%E5%BC%8F2PC%E4%B8%8E3PC%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://jantc.cn/2018/08/07/分布式2PC与3PC的区别/</id>
    <published>2018-08-07T02:39:37.000Z</published>
    <updated>2020-03-23T09:10:50.369Z</updated>
    
    <content type="html"><![CDATA[<p>整理了一下分布式2PC与3PC的区别。</p><p>知识点有所遗忘就可以回头看看这篇文章</p><a id="more"></a><h3 id="协调者"><a href="#协调者" class="headerlink" title="协调者"></a>协调者</h3><p>在分布式系统中，每一个机器节点虽然都能明确的知道自己执行的事务是成功还是失败，但是却无法知道其他分布式节点的事务执行情况。因此，当一个事务要跨越多个分布式节点的时候（比如，淘宝下单流程，下单系统和库存系统可能就是分别部署在不同的分布式节点中），为了保证该事务可以满足ACID，就要引入一个协调者（Cooradinator）。其他的节点被称为参与者（Participant）。协调者负责调度参与者的行为，并最终决定这些参与者是否要把事务进行提交。</p><h3 id="二阶段提交协议（2PC）"><a href="#二阶段提交协议（2PC）" class="headerlink" title="二阶段提交协议（2PC）"></a>二阶段提交协议（2PC）</h3><p>二阶段提交协议主要分为来个阶段：准备阶段和提交阶段。</p><p>在日常生活中其实是有很多事都是这种二阶段提交的，比如西方婚礼中就经常出现这种场景：</p><blockquote><p>牧师：”你愿意娶这个女人吗?爱她、忠诚于她，无论她贫困、患病或者残疾，直至死亡。Doyou(你愿意吗)?”</p></blockquote><blockquote><p>新郎：”Ido(我愿意)!”</p></blockquote><blockquote><p>牧师：”你愿意嫁给这个男人吗?爱他、忠诚于他，无论他贫困、患病或者残疾，直至死亡。Doyou(你愿意吗)?”</p></blockquote><blockquote><p>新娘：”Ido(我愿意)!”</p></blockquote><blockquote><p>牧师：现在请你们面向对方，握住对方的双手，作为妻子和丈夫向对方宣告誓言。</p></blockquote><blockquote><p>新郎：我——某某某，全心全意娶你做我的妻子，无论是顺境或逆境，富裕或贫穷，健康或疾病，快乐或忧愁，我都将毫无保留地爱你，我将努力去理解你，完完全全信任你。我们将成为一个整体，互为彼此的一部分，我们将一起面对人生的一切，去分享我们的梦想，作为平等的忠实伴侣，度过今后的一生。</p></blockquote><blockquote><p>新娘：我全心全意嫁给你作为你的妻子，无论是顺境或逆境，富裕或贫穷，健康或疾病，快乐或忧愁，我都将毫无保留的爱你，我将努力去理解你，完完全全信任你，我们将成为一个整体，互为彼此的一部分，我们将一起面对人生的一切，去分享我们的梦想，作为平等的忠实伴侣，度过今后的一生。</p></blockquote><p>上面这个比较经典的桥段就是一个典型的二阶段提交过程。</p><p>首先协调者（牧师）会询问两个参与者（二位新人）是否能执行事务提交操作（愿意结婚）。如果两个参与者能够执行事务的提交，先执行事务操作，然后返回YES，如果没有成功执行事务操作，就返回NO。</p><p>当协调者接收到所有的参与者的反馈之后，开始进入事务提交阶段。如果所有参与者都返回YES，那就发送COMMIT请求，如果有一个人返回NO，那就返送roolback请求。</p><p><img src="http://ooes75dyq.bkt.clouddn.com/success.png" alt="2PC成功状态示意图"></p><p><img src="http://ooes75dyq.bkt.clouddn.com/fail.png" alt="2PC失败状态示意图"></p><blockquote><p>值得注意的是，二阶段提交协议的第一阶段准备阶段不仅仅是回答YES or NO，还是要执行事务操作的，只是执行完事务操作，并没有进行commit还是roolback。和上面的结婚例子不太一样。如果非要举例的话可以理解为男女双方交换定情信物的过程。信物一旦交给对方了，这个信物就不能挪作他用了。也就是说，一旦事务执行之后，在没有执行commit或者roolback之前，资源是被锁定的。这会造成阻塞。</p></blockquote><h4 id="2PC存在的问题"><a href="#2PC存在的问题" class="headerlink" title="2PC存在的问题"></a>2PC存在的问题</h4><p>1、同步阻塞问题。执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。</p><p>2、单点故障。由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）</p><p>3、数据不一致。在二阶段提交的阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，这回导致只有一部分参与者接受到了commit请求。而在这部分参与者接到commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据部一致性的现象。</p><p>4、二阶段无法解决的问题：协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。</p><h4 id="重点讨论2PC数据一致性问题"><a href="#重点讨论2PC数据一致性问题" class="headerlink" title="重点讨论2PC数据一致性问题"></a>重点讨论2PC数据一致性问题</h4><p>作为一个分布式的一致性协议，我们主要关注他可能带来的一致性问题的。</p><h5 id="2PC在执行过程中可能发生协调者或者参与者突然宕机的情况，在不同时期宕机可能有不同的现象。"><a href="#2PC在执行过程中可能发生协调者或者参与者突然宕机的情况，在不同时期宕机可能有不同的现象。" class="headerlink" title="2PC在执行过程中可能发生协调者或者参与者突然宕机的情况，在不同时期宕机可能有不同的现象。"></a>2PC在执行过程中可能发生协调者或者参与者突然宕机的情况，在不同时期宕机可能有不同的现象。</h5><blockquote><p>情况一：协调者挂了，参与者没挂</p></blockquote><p>这种情况其实比较好解决，只要找一个协调者的替代者。当他成为新的协调者的时候，询问所有参与者的最后那条事务的执行情况，他就可以知道是应该做什么样的操作了。所以，这种情况不会导致数据不一致。</p><blockquote><p>情况二：参与者挂了，协调者没挂</p></blockquote><p>这种情况其实也比较好解决。如果协调者挂了。那么之后的事情有两种情况：</p><ul><li><p>第一个是挂了就挂了，没有再恢复。那就挂了呗，反正不会导致数据一致性问题。</p></li><li><p>第二个是挂了之后又恢复了，这时如果他有未执行完的事务操作，直接取消掉，然后询问协调者目前我应该怎么做，协调者就会比对自己的事务执行记录和该参与者的事务执行记录，告诉他应该怎么做来保持数据的一致性。</p></li></ul><blockquote><p>情况三：参与者挂了，协调者也挂了</p></blockquote><p>这种情况比较复杂，我们分情况讨论。</p><ul><li><p>协调者和参与者在第一阶段挂了。</p><ul><li>由于这时还没有执行commit操作，新选出来的协调者可以询问各个参与者的情况，再决定是进行commit还是roolback。因为还没有commit，所以不会导致数据一致性问题。</li></ul></li><li><p>第二阶段协调者和参与者挂了，挂了的这个参与者在挂之前并没有接收到协调者的指令，或者接收到指令之后还没来的及做commit或者roolback操作。</p><ul><li>这种情况下，当新的协调者被选出来之后，他同样是询问所有的参与者的情况。只要有机器执行了abort（roolback）操作或者第一阶段返回的信息是No的话，那就直接执行roolback操作。如果没有人执行abort操作，但是有机器执行了commit操作，那么就直接执行commit操作。这样，当挂掉的参与者恢复之后，只要按照协调者的指示进行事务的commit还是roolback操作就可以了。因为挂掉的机器并没有做commit或者roolback操作，而没有挂掉的机器们和新的协调者又执行了同样的操作，那么这种情况不会导致数据不一致现象。</li></ul></li><li><p>第二阶段协调者和参与者挂了，挂了的这个参与者在挂之前已经执行了操作。但是由于他挂了，没有人知道他执行了什么操作。</p><ul><li>这种情况下，新的协调者被选出来之后，如果他想负起协调者的责任的话他就只能按照之前那种情况来执行commit或者roolback操作。这样新的协调者和所有没挂掉的参与者就保持了数据的一致性，我们假定他们执行了commit。但是，这个时候，那个挂掉的参与者恢复了怎么办，因为他之前已经执行完了之前的事务，如果他执行的是commit那还好，和其他的机器保持一致了，万一他执行的是roolback操作那？这不就导致数据的不一致性了么？虽然这个时候可以再通过手段让他和协调者通信，再想办法把数据搞成一致的，但是，这段时间内他的数据状态已经是不一致的了！</li></ul></li></ul><blockquote><p>所以，2PC协议中，如果出现协调者和参与者都挂了的情况，有可能导致数据不一致。<br>为了解决这个问题，衍生除了3PC。我们接下来看看3PC是如何解决这个问题的。</p></blockquote><h3 id="三阶段提交协议（3PC）"><a href="#三阶段提交协议（3PC）" class="headerlink" title="三阶段提交协议（3PC）"></a>三阶段提交协议（3PC）</h3><p>3PC最关键要解决的就是协调者和参与者同时挂掉的问题，所以3PC把2PC的准备阶段再次一分为二，这样三阶段提交就有CanCommit、PreCommit、DoCommit三个阶段。在第一阶段，只是询问所有参与者是否可可以执行事务操作，并不在本阶段执行事务操作。当协调者收到所有的参与者都返回YES时，在第二阶段才执行事务操作，然后在第三阶段在执行commit或者rollback。</p><p><img src="http://ooes75dyq.bkt.clouddn.com/3.png" alt="3PC提交状态图"></p><p>这里再举一个生活中类似三阶段提交的例子：</p><blockquote><p>班长要组织全班同学聚餐，由于大家毕业多年，所以要逐个打电话敲定时间，时间初定10.1日。然后开始逐个打电话。</p></blockquote><blockquote><p>班长：小A，我们想定在10.1号聚会，你有时间嘛？有时间你就说YES，没有你就说NO，然后我还会再去问其他人，具体时间地点我会再通知你，这段时间你可先去干你自己的事儿，不用一直等着我。（协调者询问事务是否可以执行，这一步不会锁定资源）</p></blockquote><blockquote><p>小A：好的，我有时间。（参与者反馈）</p></blockquote><blockquote><p>班长：小B，我们想定在10.1号聚会……不用一直等我。</p></blockquote><blockquote><p>班长收集完大家的时间情况了，一看大家都有时间，那么就再次通知大家。（协调者接收到所有YES指令）</p></blockquote><blockquote><p>班长：小A，我们确定了10.1号聚餐，你要把这一天的时间空出来，这一天你不能再安排其他的事儿了。然后我会逐个通知其他同学，通知完之后我会再来和你确认一下，还有啊，如果我没有特意给你打电话，你就10.1号那天来聚餐就行了。对了，你确定能来是吧？（协调者发送事务执行指令，这一步锁住资源。如果由于网络原因参与者在后面没有收到协调者的命令，他也会执行commit）</p></blockquote><blockquote><p>小A顺手在自己的日历上把10.1号这一天圈上了，然后跟班长说，我可以去。（参与者执行事务操作，反馈状态）</p></blockquote><blockquote><p>班长：小B，我们觉得了10.1号聚餐……你就10.1号那天来聚餐就行了。</p></blockquote><blockquote><p>班长通知完一圈之后。所有同学都跟他说：”我已经把10.1号这天空出来了”。于是，他在10.1号这一天又挨个打了一遍电话告诉他们：嘿，现在你们可以出门拉。。。。（协调者收到所有参与者的ACK响应，通知所有参与者执行事务的commit）</p></blockquote><blockquote><p>小A，小B：我已经出门拉。（执行commit操作，反馈状态）</p></blockquote><h4 id="3PC为什么比2PC好？"><a href="#3PC为什么比2PC好？" class="headerlink" title="3PC为什么比2PC好？"></a>3PC为什么比2PC好？</h4><blockquote><p>直接分析协调者和参与者都挂的情况。</p></blockquote><ul><li><p>第二阶段协调者和参与者挂了，挂了的这个参与者在挂之前已经执行了操作。但是由于他挂了，没有人知道他执行了什么操作。</p><ul><li><p>这种情况下，当新的协调者被选出来之后，他同样是询问所有的参与者的情况来觉得是commit还是roolback。这看上去和二阶段提交一样啊？他是怎么解决一致性问题的呢？</p></li><li><p>看上去和二阶段提交的那种数据不一致的情况的现象是一样的，但仔细分析所有参与者的状态的话就会发现其实并不一样。我们假设挂掉的那台参与者执行的操作是commit。那么其他没挂的操作者的状态应该是什么？他们的状态要么是prepare-commit要么是commit。因为3PC的第三阶段一旦有机器执行了commit，那必然第一阶段大家都是同意commit。所以，这时，新选举出来的协调者一旦发现未挂掉的参与者中有人处于commit状态或者是prepare-commit的话，那就执行commit操作。否则就执行rollback操作。这样挂掉的参与者恢复之后就能和其他机器保持数据一致性了。（为了简单的让大家理解，笔者这里简化了新选举出来的协调者执行操作的具体细节，真实情况比我描述的要复杂）</p></li></ul></li></ul><blockquote><p>简单概括一下就是，如果挂掉的那台机器已经执行了commit，那么协调者可以从所有未挂掉的参与者的状态中分析出来，并执行commit。如果挂掉的那个参与者执行了rollback，那么协调者和其他的参与者执行的肯定也是rollback操作。</p></blockquote><blockquote><p>所以，再多引入一个阶段之后，3PC解决了2PC中存在的那种由于协调者和参与者同时挂掉有可能导致的数据一致性问题。</p></blockquote><h4 id="3PC存在的问题"><a href="#3PC存在的问题" class="headerlink" title="3PC存在的问题"></a>3PC存在的问题</h4><blockquote><p>相对于2PC，3PC主要解决的单点故障问题，并减少阻塞，因为一旦参与者无法及时收到来自协调者的信息之后，他会默认执行commit。而不会一直持有事务资源并处于阻塞状态。但是这种机制也会导致数据一致性问题。</p></blockquote><blockquote><p>因为由于网络原因，协调者发送的abort响应没有及时被参与者接收到，那么参与者在等待超时之后执行了commit操作。这样就和其他接到abort命令并执行回滚的参与者之间存在数据不一致的情况。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;整理了一下分布式2PC与3PC的区别。&lt;/p&gt;
&lt;p&gt;知识点有所遗忘就可以回头看看这篇文章&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://jantc.cn/categories/java/"/>
    
    
      <category term="分布式" scheme="http://jantc.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Semaphore的认识</title>
    <link href="http://jantc.cn/2018/07/24/Semaphore%E7%9A%84%E8%AE%A4%E8%AF%86/"/>
    <id>http://jantc.cn/2018/07/24/Semaphore的认识/</id>
    <published>2018-07-24T06:52:09.000Z</published>
    <updated>2020-03-23T09:10:50.366Z</updated>
    
    <content type="html"><![CDATA[<p>Semaphore 是一种基于技术的信号量。它可以设置一个阈值，然后多个线程竞争获取许可信号，完成后归还，超过阈值后，线程申请许可信号将会被阻塞</p><a id="more"></a><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><blockquote><ol><li>Semaphore(int permits) 参数permits表示许可数目，即同时可以允许多少线程进行访问</li><li>Semaphore(int permits, boolean fair) 多了一个参数fair表示是否是公平的，即等待时间越久的越先获取许可</li><li>availablePermits() 返回此信号量中当前可用的许可数</li><li>acquire() 申请资源</li><li>release() 释放资源</li></ol></blockquote><p>###用法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Semaphore semp = <span class="keyword">new</span> Semaphore(<span class="number">10</span>);  </span><br><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line">    <span class="comment">// 1.申请许可  </span></span><br><span class="line">    semp.acquire();  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="comment">// 2.业务逻辑  </span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">        <span class="comment">// 3.释放许可  </span></span><br><span class="line">        semp.release();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>###案例</p><blockquote><ul><li>在测试环境有5台机器可供测试发布，但是有10个需求需要发到测试环境进行验证。</li><li>假设10个需求的编号分别为1-10，哪个需求先发布，哪个需求就可以开始测试。测试环境一台机器只能测试一个需求，不能共享</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTestJob</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String ip;</span><br><span class="line">    <span class="keyword">private</span> Semaphore semaphore;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTestJob</span><span class="params">(String ip, Semaphore semaphore)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ip = ip;</span><br><span class="line">        <span class="keyword">this</span>.semaphore = semaphore;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.获取可以用的测试环境机器数目，然后申请测试环境一台机器用来测试发布</span></span><br><span class="line">        <span class="keyword">int</span> availableIps = semaphore.availablePermits();</span><br><span class="line">        <span class="keyword">if</span> (availableIps &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 表示还有空闲机器可以用于发布测试</span></span><br><span class="line">            System.out.println(<span class="string">"还有空闲机器可供测试发布"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"无空闲机器可供测试发布"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            semaphore.acquire();</span><br><span class="line">            System.out.println(ip + <span class="string">":正在发布验证需求..."</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(ip + <span class="string">": 需求验证完毕！"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            semaphore.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Job</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyTestJob(<span class="string">"ip"</span>+i,semaphore)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Clog:<br>还有空闲机器可供测试发布<br>还有空闲机器可供测试发布<br>ip4:正在发布验证需求…<br>ip1:正在发布验证需求…<br>还有空闲机器可供测试发布<br>ip5:正在发布验证需求…<br>还有空闲机器可供测试发布<br>ip8:正在发布验证需求…<br>还有空闲机器可供测试发布<br>ip3:正在发布验证需求…<br>无空闲机器可供测试发布<br>无空闲机器可供测试发布<br>无空闲机器可供测试发布<br>无空闲机器可供测试发布<br>无空闲机器可供测试发布<br>ip4: 需求验证完毕！<br>ip6:正在发布验证需求…<br>ip1: 需求验证完毕！<br>ip7:正在发布验证需求…<br>ip5: 需求验证完毕！<br>ip8: 需求验证完毕！<br>ip3: 需求验证完毕！<br>ip2:正在发布验证需求…<br>ip9:正在发布验证需求…<br>ip10:正在发布验证需求…<br>ip6: 需求验证完毕！<br>ip7: 需求验证完毕！<br>ip2: 需求验证完毕！<br>ip9: 需求验证完毕！<br>ip10: 需求验证完毕！</p></blockquote><h3 id="应用场景：分布式锁"><a href="#应用场景：分布式锁" class="headerlink" title="应用场景：分布式锁"></a>应用场景：分布式锁</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Semaphore 是一种基于技术的信号量。它可以设置一个阈值，然后多个线程竞争获取许可信号，完成后归还，超过阈值后，线程申请许可信号将会被阻塞&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://jantc.cn/categories/java/"/>
    
    
      <category term="Java8" scheme="http://jantc.cn/tags/Java8/"/>
    
  </entry>
  
  <entry>
    <title>Java8 Optional的正确认识</title>
    <link href="http://jantc.cn/2018/01/29/Java8-Optional%E7%9A%84%E6%AD%A3%E7%A1%AE%E8%AE%A4%E8%AF%86/"/>
    <id>http://jantc.cn/2018/01/29/Java8-Optional的正确认识/</id>
    <published>2018-01-29T11:08:18.000Z</published>
    <updated>2020-03-23T09:10:50.360Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道 Java 8 增加了一些很有用的 API, 其中一个就是 Optional. 如果对它不稍假探索, 只是轻描淡写的认为它可以优雅的解决 NullPointException 的问题, 于是代码就开始这么写了</p><a id="more"></a><blockquote><p>Optional<user> user = ……</user></p></blockquote><blockquote><p>if (user.isPresent()) {</p></blockquote><blockquote><p>return user.getOrders();</p></blockquote><blockquote><p>} else {</p></blockquote><blockquote><p>return Collections.emptyList();</p></blockquote><blockquote><p>}</p></blockquote><p>那么不得不说我们的思维仍然是在原地踏步, 只是本能的认为它不过是 User 实例的包装, 这与我们之前写成</p><blockquote><p>User user = …..</p></blockquote><blockquote><p>if (user != null) {</p></blockquote><blockquote><p>return user.getOrders();</p></blockquote><blockquote><p>} else {</p></blockquote><blockquote><p>return Collections.emptyList();</p></blockquote><blockquote><p>}<br>实质上是没有任何分别. 这就是我们将要讲到的使用好 Java 8 Optional 类型的正确姿势.</p></blockquote><p>在里约奥运之时, 新闻一再提起五星红旗有问题, 可是我怎么看都看不出来有什么问题, 后来才道是小星星膜拜中央的姿势不对. 因此我们千万也别对自己习以为常的事情觉得理所当然, 丝毫不会觉得有何不妥, 换句话说也就是当我们切换到 Java 8 的 Optional 时, 不能继承性的对待过往 null 时的那种思维, 应该掌握好新的, 正确的使用 Java 8 Optional 的正确姿势.</p><p>直白的讲, 当我们还在以如下几种方式使用 Optional 时, 就得开始检视自己了</p><p>调用 isPresent()  方法时<br>调用 get()  方法时<br>Optional 类型作为类/实例属性时<br>Optional 类型作为方法参数时<br>isPresent() 与 obj != null 无任何分别, 我们的生活依然在步步惊心. 而没有 isPresent() 作铺垫的 get() 调用在 IntelliJ IDEA 中会收到告警</p><blockquote><p>Reports calls to java.util.Optional.get() without first checking with a isPresent() call if a value is available. If the Optional does not contain a value, get() will throw an exception. (调用 Optional.get() 前不事先用 isPresent() 检查值是否可用. 假如 Optional 不包含一个值, get() 将会抛出一个异常)</p></blockquote><p>把 Optional 类型用作属性或是方法参数在 IntelliJ IDEA 中更是强力不推荐的</p><blockquote><p>Reports any uses of java.util.Optional<t>, java.util.OptionalDouble, java.util.OptionalInt, java.util.OptionalLong or com.google.common.base.Optional as the type for a field or a parameter. Optional was designed to provide a limited mechanism for library method return types where there needed to be a clear way to represent “no result”. Using a field with type java.util.Optional is also problematic if the class needs to be Serializable, which java.util.Optional is not. (使用任何像 Optional 的类型作为字段或方法参数都是不可取的. Optional 只设计为类库方法的, 可明确表示可能无值情况下的返回类型. Optional 类型不可被序列化, 用作字段类型会出问题的)</t></p></blockquote><p>所以 Optional 中我们真正可依赖的应该是除了 isPresent() 和 get() 的其他方法:</p><blockquote><p>public<u> Optional<u> map(Function&lt;? super T, ? extends U&gt; mapper)<br>public T orElse(T other)<br>public T orElseGet(Supplier&lt;? extends T&gt; other)<br>public void ifPresent(Consumer&lt;? super T&gt; consumer)<br>public Optional<t> filter(Predicate&lt;? super T&gt; predicate)<br>public<u> Optional<u> flatMap(Function&lt;? super T, Optional<u>&gt; mapper)<br>public <x extends throwable> T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) throws X</x></u></u></u></t></u></u></p></blockquote><p>我略有自信的按照它们大概使用频度对上面的方法排了一下序.</p><p>先又不得不提一下 Optional 的三种构造方式: Optional.of(obj) ,   Optional.ofNullable(obj) 和明确的 Optional.empty()</p><p>Optional.of(obj) : 它要求传入的 obj 不能是 null 值的, 否则还没开始进入角色就倒在了 NullPointerException 异常上了.</p><p>Optional.ofNullable(obj) : 它以一种智能的, 宽容的方式来构造一个 Optional 实例. 来者不拒, 传 null 进到就得到 Optional.empty() , 非 null 就调用 Optional.of(obj) .</p><p>那是不是我们只要用 Optional.ofNullable(obj) 一劳永逸, 以不变应二变的方式来构造 Optional 实例就行了呢? 那也未必, 否则 Optional.of(obj) 何必如此暴露呢, 私有则可?</p><p>我本人的观点是:  1. 当我们非常非常的明确将要传给 Optional.of(obj) 的 obj 参数不可能为 null 时, 比如它是一个刚 new 出来的对象( Optional.of(new User(…)) ), 或者是一个非 null 常量时;  2. 当想为 obj 断言不为 null 时, 即我们想在万一 obj 为 null 立即报告 NullPointException 异常, 立即修改, 而不是隐藏空指针异常时, 我们就应该果断的用 Optional.of(obj) 来构造 Optional 实例, 而不让任何不可预计的 null 值有可乘之机隐身于 Optional 中.</p><p>现在才开始怎么去使用一个已有的 Optional 实例, 假定我们有一个实例 Optional<user> user , 下面是几个普遍的, 应避免 if(user.isPresent()) { … } else { … } 几中应用方式.</user></p><p>存在即返回, 无则提供默认值</p><blockquote><p>return user.orElse(null);  //而不是 return user.isPresent() ? user.get() : null;<br>return user.orElse(UNKNOWN_USER);<br>存在即返回, 无则由函数来产生<br>return user.orElseGet(() -&gt; fetchAUserFromDatabase()); //而不要 return user.isPresent() ? user: fetchAUserFromDatabase();<br>存在才对它做点什么<br>user.ifPresent(System.out::println);</p></blockquote><p>//而不要下边那样</p><blockquote><p>if (user.isPresent()) {<br>  System.out.println(user.get());<br>}</p></blockquote><p>map 函数隆重登场<br>当 user.isPresent() 为真, 获得它关联的 orders , 为假则返回一个空集合时, 我们用上面的 orElse , orElseGet 方法都乏力时, 那原本就是 map 函数的责任, 我们可以这样一行</p><blockquote><p>return user.map(u -&gt; u.getOrders()).orElse(Collections.emptyList())</p></blockquote><p>//上面避免了我们类似 Java 8 之前的做法</p><blockquote><p>if(user.isPresent()) {<br>  return user.get().getOrders();<br>} else {<br>  return Collections.emptyList();<br>}</p></blockquote><p>map 是可能无限级联的, 比如再深一层, 获得用户名的大写形式</p><blockquote><p>return user.map(u -&gt; u.getUsername())<br>           .map(name -&gt; name.toUpperCase())<br>           .orElse(null);</p></blockquote><p>这要搁在以前, 每一级调用的展开都需要放一个 null 值的判断</p><blockquote><p>User user = …..<br>if(user != null) {<br>  String name = user.getUsername();<br>  if(name != null) {<br>    return name.toUpperCase();<br>  } else {<br>    return null;<br>  }<br>} else {<br>  return null;<br>}</p></blockquote><p>针对这方面 Groovy 提供了一种安全的属性/方法访问操作符 ?.</p><blockquote><p>user?.getUsername()?.toUpperCase();</p></blockquote><p>Swift 也有类似的语法, 只作用在  Optional 的类型上.</p><p>用了 isPresent() 处理 NullPointerException 不叫优雅, 有了  orElse, orElseGet 等, 特别是 map 方法才叫优雅.</p><p>其他几个, filter() 把不符合条件的值变为 empty() ,   flatMap() 总是与 map() 方法成对的,   orElseThrow() 在有值时直接返回, 无值时抛出想要的异常.</p><p>一句话小结: 使用 Optional 时尽量不直接调用 Optional.get() 方法, Optional.isPresent() 更应该被视为一个私有方法, 应依赖于其他像 Optional.orElse() , Optional.orElseGet() , Optional.map() 等这样的方法.</p><p>最后, 最好的理解 Java 8 Optional 的方法莫过于看它的源代码java.util.Optional , 阅读了源代码才能真真正正的让你解释起来最有底气, Optional 的方法中基本都是内部调用   isPresent() 判断, 真时处理值, 假时什么也不做.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道 Java 8 增加了一些很有用的 API, 其中一个就是 Optional. 如果对它不稍假探索, 只是轻描淡写的认为它可以优雅的解决 NullPointException 的问题, 于是代码就开始这么写了&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://jantc.cn/categories/java/"/>
    
    
      <category term="Java8" scheme="http://jantc.cn/tags/Java8/"/>
    
  </entry>
  
  <entry>
    <title>Java8之Steam(一)</title>
    <link href="http://jantc.cn/2018/01/26/Java8%E4%B9%8BSteam-%E4%B8%80/"/>
    <id>http://jantc.cn/2018/01/26/Java8之Steam-一/</id>
    <published>2018-01-26T08:26:37.000Z</published>
    <updated>2020-03-23T09:10:50.362Z</updated>
    
    <content type="html"><![CDATA[<p>流是Java8引入的全新概念，它用来处理集合中的数据，暂且可以把它理解为一种高级集合。</p><a id="more"></a><h4 id="1-1-获取流"><a href="#1-1-获取流" class="headerlink" title="1.1 获取流"></a>1.1 获取流</h4><p>1.集合</p><blockquote><p>List&lt;Person&gt; list = new ArrayList&lt;Person&gt;();<br>Stream&lt;Person&gt; stream = list.stream();</p></blockquote><p>2.数组</p><blockquote><p>String[] names = {“chaimm”,”peter”,”john”};<br>Stream&lt;String&gt; stream = Arrays.stream(names);</p></blockquote><p>3.值</p><blockquote><p>Stream&lt;String&gt; stream = Stream.of(“chaimm”,”peter”,”john”);</p></blockquote><h4 id="1-2-筛选filter"><a href="#1-2-筛选filter" class="headerlink" title="1.2 筛选filter"></a>1.2 筛选filter</h4><blockquote><p>List&lt;Person&gt; result = list.stream()<br>                    .filter(Person::isStudent)<br>                    .collect(toList());</p></blockquote><h4 id="1-3-去重distinct"><a href="#1-3-去重distinct" class="headerlink" title="1.3 去重distinct"></a>1.3 去重distinct</h4><blockquote><p>List&lt;Person&gt; result = list.stream()<br>                    .distinct()<br>                    .collect(toList());</p></blockquote><h4 id="1-4-截取"><a href="#1-4-截取" class="headerlink" title="1.4 截取"></a>1.4 截取</h4><blockquote><p>List&lt;Person&gt; result = list.stream()<br>                    .limit(3)<br>                    .collect(toList());</p></blockquote><h4 id="1-5-跳过"><a href="#1-5-跳过" class="headerlink" title="1.5 跳过"></a>1.5 跳过</h4><blockquote><p>List&lt;Person&gt; result = list.stream()<br>                    .skip(3)<br>                    .collect(toList());</p></blockquote><h4 id="1-6-映射"><a href="#1-6-映射" class="headerlink" title="1.6 映射"></a>1.6 映射</h4><blockquote><p>List&lt;Person&gt; result = list.stream()<br>                    .map(Person::getName)<br>                    .collect(toList());</p></blockquote><h4 id="1-7-是否匹配任一元素：anyMatch"><a href="#1-7-是否匹配任一元素：anyMatch" class="headerlink" title="1.7 是否匹配任一元素：anyMatch"></a>1.7 是否匹配任一元素：anyMatch</h4><blockquote><p>boolean result = list.stream()<br>            .anyMatch(Person::isStudent);</p></blockquote><h4 id="1-8-是否匹配所有元素：allMatch"><a href="#1-8-是否匹配所有元素：allMatch" class="headerlink" title="1.8 是否匹配所有元素：allMatch"></a>1.8 是否匹配所有元素：allMatch</h4><blockquote><p>boolean result = list.stream()<br>            .allMatch(Person::isStudent);</p></blockquote><h4 id="1-9-是否未匹配所有元素：noneMatch"><a href="#1-9-是否未匹配所有元素：noneMatch" class="headerlink" title="1.9 是否未匹配所有元素：noneMatch"></a>1.9 是否未匹配所有元素：noneMatch</h4><blockquote><p>boolean result = list.stream()<br>            .noneMatch(Person::isStudent);</p></blockquote><h4 id="1-10-获取任一元素findAny"><a href="#1-10-获取任一元素findAny" class="headerlink" title="1.10 获取任一元素findAny"></a>1.10 获取任一元素findAny</h4><blockquote><p>Optional&lt;Person&gt; person = list.stream()<br>                                    .findAny();</p></blockquote><h4 id="1-11-获取第一个元素findFirst"><a href="#1-11-获取第一个元素findFirst" class="headerlink" title="1.11 获取第一个元素findFirst"></a>1.11 获取第一个元素findFirst</h4><blockquote><p>Optional&lt;Person&gt; person = list.stream()<br>                                    .findFirst();</p></blockquote><h4 id="1-12-归约"><a href="#1-12-归约" class="headerlink" title="1.12 归约"></a>1.12 归约</h4><p>元素求和：自定义Lambda表达式实现求和</p><p>例：计算所有人的年龄总和</p><blockquote><p>int age = list.stream().reduce(0, (person1,person2)-&gt;person1.getAge()+person2.getAge());</p></blockquote><p>reduce的第一个参数表示初试值为0；<br>reduce的第二个参数为需要进行的归约操作，它接收一个拥有两个参数的Lambda表达式，reduce会把流中的元素两两输给Lambda表达式，最后将计算出累加之和。</p><p>元素求和：使用Integer.sum函数求和</p><p>上面的方法中我们自己定义了Lambda表达式实现求和运算，如果当前流的元素为数值类型，那么可以使用Integer提供了sum函数代替自定义的Lambda表达式，如：</p><blockquote><p>int age = list.stream().reduce(0, Integer::sum);</p></blockquote><p>Integer类还提供了min、max等一系列数值操作，当流中元素为数值类型时可以直接使用。</p><h4 id="1-13-将普通流转换成数值流"><a href="#1-13-将普通流转换成数值流" class="headerlink" title="1.13 将普通流转换成数值流"></a>1.13 将普通流转换成数值流</h4><p>StreamAPI提供了三种数值流：IntStream、DoubleStream、LongStream，也提供了将普通流转换成数值流的三种方法：mapToInt、mapToDouble、mapToLong。<br>如，将Person中的age转换成数值流：</p><blockquote><p>IntStream stream = list.stream()<br>                            .mapToInt(Person::getAge);</p></blockquote><h4 id="1-14-数值计算"><a href="#1-14-数值计算" class="headerlink" title="1.14 数值计算"></a>1.14 数值计算</h4><p>每种数值流都提供了数值计算函数，如max、min、sum等。<br>如，找出最大的年龄：</p><blockquote><p>OptionalInt maxAge = list.stream()<br>                                .mapToInt(Person::getAge)<br>                                .max();</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;流是Java8引入的全新概念，它用来处理集合中的数据，暂且可以把它理解为一种高级集合。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://jantc.cn/categories/java/"/>
    
    
      <category term="Java8" scheme="http://jantc.cn/tags/Java8/"/>
    
  </entry>
  
  <entry>
    <title>程序猿的把妹指南：概述篇</title>
    <link href="http://jantc.cn/2017/12/29/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E7%9A%84%E6%8A%8A%E5%A6%B9%E6%8C%87%E5%8D%97%EF%BC%9A%E6%A6%82%E8%BF%B0%E7%AF%87/"/>
    <id>http://jantc.cn/2017/12/29/程序猿的把妹指南：概述篇/</id>
    <published>2017-12-29T09:05:33.000Z</published>
    <updated>2020-03-23T09:10:50.381Z</updated>
    
    <content type="html"><![CDATA[<p>把妹是一门非常复杂的学问，以把妹为事业的人称为PUA(Pick-up Artist)，俗称把妹达人。而本篇文章只是一个概述，让你开始了解女人的世界，了解把妹的一些基本知识。<br><a id="more"></a></p><h4 id="每个女人都是一套系统"><a href="#每个女人都是一套系统" class="headerlink" title="每个女人都是一套系统"></a>每个女人都是一套系统</h4><p>每个女人，都是一套复杂的系统，只不过，这套系统不是由程序员创造的，而是由大自然进化而成的。大部分程序猿不太懂得如何泡妞，是因为你不熟悉女人这套系统，也没人教过你如何学习这套系统。本指南将给你提供指引，让你开始了解女人这套系统，并指引你如何征服这套系统的方法和道路。</p><p>我们知道，操作系统分Linux、Windows、OS X、Android、iOS等等，同样的，女人这套系统也是有分类的。大部分女人就像Windows一样，容易上手，不过相貌平平，非常大众化没什么特色；而像OS X的女人很高大上，但不是每个人都玩得起；像Linux的女人很有深度，也比较有个性，有Ubuntu、CentOS、Fedora、OpenSuse等等，都不一样，不熟悉的人是不懂怎么玩的。</p><p>我们也知道，每个操作系统都会不断升级版本，比如，Linux的每次升级，安全性越来越高；Windows从XP到Vista、Win7，再到现在的Win10，界面也越来越漂亮了。同样的，女人也是会不断升级的，所以越成熟的女人越难泡，这是基本常识。</p><p>那么，女人既然有这么多分类，还有不同版本，我们该从何入手呢？</p><p>虽然有那么多操作系统，但这些操作系统基本都是基于Unix或Linux内核的，也就是说，它们在本质上是一样的，是有很多共性的。女人也一样，有着相同的本质，有着很多一致的共性。懂得了这些本质，这些共性，就掌握了学会把妹的根基。</p><h4 id="爱情基于价值吸引"><a href="#爱情基于价值吸引" class="headerlink" title="爱情基于价值吸引"></a>爱情基于价值吸引</h4><p>女人的第一个本质共性是：容易被男人的高价值所吸引。吸引力等同于你进入她的这套系统的登录密码，没有密码，你就进不去。从本质上看，爱情就是基于价值吸引之上的。男人往往会被女人的繁殖价值所吸引，即男人倾向于喜欢年轻貌美、身材匀称、容易生育的女人。</p><p>而女人则更多被男人的生存价值所吸引，即女人更看重：健壮的体格、社交智慧、幽默、社会地位、财富、身高、自信、雄心、拥有的资源以及潜在的资源获取能力等等。</p><p>如果你拥有以上这些特性，就说明你具有高价值，拥有的特性越多，说明你的价值越高，也就更容易吸引到异性。因此，如果你喜欢某个女人，那你就应该向她传递高价值，以此来吸引她。而不是一味对她好，一味讨好她，这是低价值的表现。很多男人，尤其是很多程序猿，总是对女人好，以为对她好，总有一天她会感动得投入你的怀抱，这是大错特错的。你一味对她好，现实的结果一般只有两种：收到好人卡，或成为备胎。</p><p>另外，男女之间的价值吸引也是有匹配度的。比如，你喜欢林志玲，但你拥有能配得上她的高价值吗？所以，如果你只具备Windows级别的价值，想吸引OS X级别的美女，很难。你必须不断提升自己，慢慢将自己提升到拥有OS X级别的高价值。很多高价值都是可以通过努力学习得到提升的，比如健壮的体格可以通过健身得到提升，社交智慧可以通过多参加社交活动而增强，幽默通过看多些案例就可以培养了。</p><p>大部分程序猿还是具有高价值的，只是不懂得如何展示出来；相反，却总是展示出了低价值。如何展示高价值，存在很多方法，其中包括扮孔雀、预选、社交认证、否定等等。具体后续再讲。</p><h4 id="女人都是感性的"><a href="#女人都是感性的" class="headerlink" title="女人都是感性的"></a>女人都是感性的</h4><p>女人的第二个本质共性就是：感性远远高于理性，在性选择方面同样如此。<br>女人的很多行为都是情绪化的，而不是经过理性分析后做出决定而行动的。比如，女人会疯狂购物，尤其是心情不好时，尤其在双11，这不是理性的结果。也经常听她们说挑选男朋友的标准，比如要高学历、高收入、高身材啦，比如要性格温和、不吸烟、少喝酒啦，等等。但最后交往的男朋友却跟她之前说的标准相差甚远，身高不达标，收入也不达标，又吸烟又喝酒，性格也不温和，但她就是喜欢，可能就只是因为他的幽默吸引了她。也就是说，女人被男人吸引，也不是理性的选择，纯粹是感性的结果。</p><p>一个女人从一开始被你吸引，到愿意与你进行身体接触，到愿意和你Kiss，到最后和你上床。这一系列过程的每个阶段，都是因为女人的某些情绪密码被你激活了，从而才愿意一步一步被你征服。</p><p>当她开始被你吸引，激发了她对你的兴趣，她就会愿意和你聊天说话，这时等于给了你一个访问密码，让你开始进入她的系统。不过你的权限非常有限，只拥有一些浅层次信息的读取权限，没有更多了。接着，你进一步与她进行社交互动，激发出她与你情绪上的共振，那她就会升级你的权限，可以让你读取到一些更私密的信息。接下来，你加强建立与她情感上的联系感，也就是恋爱的感觉，那这时候她就会愿意与你有肢体上的接触，意味着你不只有读的权限，也开始有一些写的权限了。最后，你努力激发出她的性欲，她愿意与你上床，你连执行的权限也得到了。</p><h4 id="反荡妇防卫机制"><a href="#反荡妇防卫机制" class="headerlink" title="反荡妇防卫机制"></a>反荡妇防卫机制</h4><p>女人的第三个本质共性就是：拥有一套针对男人的强力的干扰机制，称为反荡妇防卫机制。</p><p>什么是反荡妇防卫机制？可以将其理解为女人这套系统里面的防火墙，说白了就是女人本能上会避免感觉像个荡妇的别扭感，所以女人在男女关系中一般不会主动，也不会轻易答应你的请求，尤其是更深层次的接触时，比如Kiss、Sex。比如，你对她说：“让我吻你吧”，即使她心里同意，她嘴里也会拒绝。所以，如果要吻她，你不用问。</p><p>如果你不了解女人的这套防卫机制，那你在追求她的过程中，一被拒绝就以为她心里对你产生了抗拒，从而放弃，那你就错了。另外，如果你不了解女人的这套防卫机制，那你也分辨不出她的哪些拒绝是真正的抵触，哪些只是象征性的Say no。</p><p>当你了解了女人的这套防卫机制，你就可以采取相应的合理措施，尽量避免踩雷，可以采用迂回战术。举个例子，你想让她上你家，那你可以对她说：“先去我家坐坐吧，我想让你看我家的狗狗，它会跳舞。”这样她就有借口与合理的余地去你家了，接下来怎么做，就不明说了，傻瓜才会真的只看看狗狗。</p><h4 id="把妹框架"><a href="#把妹框架" class="headerlink" title="把妹框架"></a>把妹框架</h4><p>开发程序时，有很多框架可以帮助我们提高开发效率，Java Web开发有Spring、Hibernate等，Android有OKHttp、Volley、ButterKnife等，iOS有AFNetworking、SDWebImage等。同样，把妹也有很多框架，同样可以帮助我们提高把妹的成功率。其中，最有名的一套框架叫做谜男方法，它也是开源的。谜男方法将整个把妹的过程划分为几个阶段，并告诉你每个阶段该做什么，怎么做。那么，具体分为了哪几个阶段呢？我们知道，一个程序，需要经过开发、测试、部属三个阶段，谜男方法，也将把妹流程划分为三大阶段：吸引(Attract)、建立舒适感(Build Comfort)、诱惑(Seduce)，每个阶段又各自拆解为三个小阶段，因此，总共划分为九个阶段：</p><p>A1——打开组合：男方接近一个组合，执行开场白，并立刻被这个组合接受。<br>A2——女对男的兴趣：男方展示较高的价值，同时显示对目标没兴趣，她则以兴趣指标回应。<br>A3——男对女的兴趣：男方引诱女方在互动中投资更多，然后以兴趣指标奖赏她的努力。<br>C1——对话：两人分享友善的对话，培养舒适感与熟悉感。<br>C2——联系感：双方感到“来电”的悸动，发生接吻，这个阶段可能延续好几次约会。<br>C3——亲密感：现在是在诱惑的地点，继续发生激烈调情，双方进入卧房。<br>S1——前戏：两人开始往性交方向发展，如果太早发生，可能会引发事后反悔。<br>S2——LMR：最后一刻的抵抗是性爱发生之前的不归点，通常是女人临阵退缩的时刻。<br>S3——性交：必须发生好几次性交以确保性关系。</p><p>除了谜男方法，当然还有其他把妹框架，比如杂耍人方法、DavidX方法、Tango方法等，只是侧重点不同。比如，OKHttp是网络框架，ButterKnife是注解框架。而杂耍人方法专注于与女性交流，DavidX方法则更多侧重于自我建设，Tango方法与谜男方法类似，不过只分为了五个步骤：自身建设、建立与管理目标存库、吸引、升级、性。</p><h4 id="实践出真知"><a href="#实践出真知" class="headerlink" title="实践出真知"></a>实践出真知</h4><p>你是怎么学会Java Web开发，或Android开发，或iOS开发的？你只是看一大堆书或视频，然后就变成编程能手了吗？你在学习过程中，就没有处处碰壁吗，明明按照教程敲的代码，怎么跑起来就是出错呢？每个程序猿都是在不断敲代码的过程中慢慢成长的，同样道理，把妹也是需要经过实践练习的。你不可能学会一大堆把妹理论之后就能成为把妹达人，把妹达人都是经过无数次的实践练习才慢慢成长为把妹达人的。</p><p>当然，你的目标可能并不是想成为把妹达人，就好像很多程序猿的目标也不是要成为架构师。但你至少也要追到一个女朋友吧，还是你喜欢孤独终老？那么，追女朋友就好像做一个app，从功能范围的筛选，到界面的设计，到开发测试，到最后上线，你都要懂。虽然做一个app可以分工，有人做需求，有人做设计，有人做测试，有人做部署，而你只做开发。但追女朋友可没有人可以帮你做这些的，让别人帮你女朋友“上线”(Sex)，这可以吗，你愿意吗？所以，整个流程你必须自己搞定，别人只能给你提供建议，但必须你自己去实践。</p><p>所以，改变从此刻开始，走出你的房间吧，不要再宅在家里了，出去外面开始练习吧。你知道谜男对把妹菜鸟提出的练习次数吗：每周出门四次（四个晚上），每次四个小时，每小时打开组合三次。加起来每晚打开12个组合，每周48个，每月两百个，总共加起来，每年会有2000次搭讪！你活到现在，搭讪了几个女生？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;把妹是一门非常复杂的学问，以把妹为事业的人称为PUA(Pick-up Artist)，俗称把妹达人。而本篇文章只是一个概述，让你开始了解女人的世界，了解把妹的一些基本知识。&lt;br&gt;
    
    </summary>
    
      <category term="life" scheme="http://jantc.cn/categories/life/"/>
    
    
      <category term="life" scheme="http://jantc.cn/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>网易云跟帖倒闭,接入Gitment</title>
    <link href="http://jantc.cn/2017/07/10/%E7%BD%91%E6%98%93%E4%BA%91%E8%B7%9F%E5%B8%96%E5%80%92%E9%97%AD-%E6%8E%A5%E5%85%A5Gitment/"/>
    <id>http://jantc.cn/2017/07/10/网易云跟帖倒闭-接入Gitment/</id>
    <published>2017-07-10T09:14:53.000Z</published>
    <updated>2020-03-23T09:10:50.382Z</updated>
    
    <content type="html"><![CDATA[<p>罗列一下目前还在苟延残喘的第三方评论系统</p><h4 id="畅言"><a href="#畅言" class="headerlink" title="畅言"></a>畅言</h4><p>必须要备案，备个案要花将近一个月的时间，通过看人品。所以直接pass</p><h4 id="友言"><a href="#友言" class="headerlink" title="友言"></a>友言</h4><p>不是很稳定，经常评论无法加载，而且项目组转战其他，基本上处于放弃状态。<br><a id="more"></a></p><h4 id="来必力"><a href="#来必力" class="headerlink" title="来必力"></a>来必力</h4><p>这个是韩国的评论系统，唯一一点不好的就是当你访问量超过1500的时候，就会有广告显示。这个时候需要你掏Money了。而且貌似QQ登陆没有昵称显示，对于强迫症患者是非常痛苦的。</p><h4 id="Disqus"><a href="#Disqus" class="headerlink" title="Disqus"></a>Disqus</h4><p>墙墙墙，你可以去打穿这个墙</p><h4 id="Gitment"><a href="#Gitment" class="headerlink" title="Gitment"></a>Gitment</h4><p>强烈推荐,不需要太多技术，不需要太多配置。就是辣么酸爽。<a href="https://imsun.net/posts/gitment-introduction/" target="_blank" rel="noopener">Gitment官方大佬教程</a></p><p><img src="http://ooes75dyq.bkt.clouddn.com/jiong.png" alt="enter image description here"></p><p><center>用多说，多说倒闭。<br>用网易云跟帖，云跟帖跑路。<br>Gitment 您一定要给我坚持就点。</center></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;罗列一下目前还在苟延残喘的第三方评论系统&lt;/p&gt;
&lt;h4 id=&quot;畅言&quot;&gt;&lt;a href=&quot;#畅言&quot; class=&quot;headerlink&quot; title=&quot;畅言&quot;&gt;&lt;/a&gt;畅言&lt;/h4&gt;&lt;p&gt;必须要备案，备个案要花将近一个月的时间，通过看人品。所以直接pass&lt;/p&gt;
&lt;h4 id=&quot;友言&quot;&gt;&lt;a href=&quot;#友言&quot; class=&quot;headerlink&quot; title=&quot;友言&quot;&gt;&lt;/a&gt;友言&lt;/h4&gt;&lt;p&gt;不是很稳定，经常评论无法加载，而且项目组转战其他，基本上处于放弃状态。&lt;br&gt;
    
    </summary>
    
    
      <category term="life" scheme="http://jantc.cn/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>同步方式导出Excel的小问题</title>
    <link href="http://jantc.cn/2017/04/24/%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F%E5%AF%BC%E5%87%BAExcel%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98/"/>
    <id>http://jantc.cn/2017/04/24/同步方式导出Excel的小问题/</id>
    <published>2017-04-24T04:51:59.000Z</published>
    <updated>2020-03-23T09:10:50.371Z</updated>
    
    <content type="html"><![CDATA[<p>最近有个需求，需要同步导出Excel，对非异步。</p><p>那么ajax是不能使用的，而且要提醒用户现在是正在下载Excel的，需要在导出按钮点击后，弹出一个div，提示用户”数据正在导出中，请稍后”，现在问题来了，我们如何获取数据下载完成的标记位呢。问题也就是变成了：如何在下载结束后关闭这个div</p><a id="more"></a><p>因为是同步操作，意味着在导出下载Excel这个请求不能断，要一直进行。一直进行页面就会处于一种假死状态（其实一直在导出下载Excel）</p><p>目前没有想到好的方法可以直接获取”请求结束,下载完成”这个标记，也不知道是否存在这样的一个标记能够直接定位。</p><p>目前采取的方式是：export操作同步进行，当下载完成后再代码块finally{}中，自己创建一个标识，例如downloadtags写入redis。然后页面上单开一个定时器，每个800ms触发ajax去获取标识，如果能够获取到，则提醒用户下载完成，提示下载完成。关闭div…</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    self.setInterval(<span class="string">"checktags()"</span>,<span class="number">800</span>);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">checktags</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                  $.ajax(&#123;</span><br><span class="line">               type: <span class="string">'POST'</span>,</span><br><span class="line">               url: url,</span><br><span class="line">               dataType: <span class="string">'json'</span>,</span><br><span class="line">               success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">                   <span class="keyword">if</span>(data)&#123;</span><br><span class="line">                       $(<span class="string">"#downloading"</span>).hide();</span><br><span class="line">                       $(<span class="string">".trade-foot"</span>).show();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>Thanks!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近有个需求，需要同步导出Excel，对非异步。&lt;/p&gt;
&lt;p&gt;那么ajax是不能使用的，而且要提醒用户现在是正在下载Excel的，需要在导出按钮点击后，弹出一个div，提示用户”数据正在导出中，请稍后”，现在问题来了，我们如何获取数据下载完成的标记位呢。问题也就是变成了：如何在下载结束后关闭这个div&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://jantc.cn/categories/java/"/>
    
    
      <category term="ajax" scheme="http://jantc.cn/tags/ajax/"/>
    
  </entry>
  
  <entry>
    <title>踩坑集锦一之浏览器兼容问题</title>
    <link href="http://jantc.cn/2017/04/19/%E8%B8%A9%E5%9D%91%E9%9B%86%E9%94%A6%E4%B8%80%E4%B9%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98/"/>
    <id>http://jantc.cn/2017/04/19/踩坑集锦一之浏览器兼容问题/</id>
    <published>2017-04-19T15:26:34.000Z</published>
    <updated>2020-03-23T09:10:50.385Z</updated>
    
    <content type="html"><![CDATA[<p>最近在项目中遇到一个浏览器兼容性问题。</p><p>背景: 用户点击某图标，弹出提示框，2s后提示框消失。</p><a id="more"></a><p>目前的做法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">"javascript:$('.d-layer').show();$('.d-layer').delay(3000).hide(0)"</span>&gt;&lt;img src="xxx"/&gt;&lt;<span class="regexp">/a&gt;</span></span><br></pre></td></tr></table></figure></p><p>在谷歌浏览器中这种能够正常达到需求，但是在IE浏览器下（IE11）、火狐浏览器（50.0.2）不能够正常兼容</p><p>后面改成：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">"#"</span> onclick=<span class="string">"javascript:$('.d-layer').show();$('.d-layer').delay(3000).hide(0)"</span>&gt;&lt;img src="xxx"/&gt;&lt;<span class="regexp">/a&gt;</span></span><br></pre></td></tr></table></figure></p><p>解决了三者的兼容性问题。</p><blockquote><p>经实验 ，发现火狐浏览器标签a的href执行js代码时不能执行台复杂的语句，只能执行单语句代码。</p></blockquote><p>例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">"javascript:func();"</span> <span class="comment">//可以执行</span></span><br><span class="line">&lt;a href=<span class="string">"javascript:func();funb();"</span> <span class="comment">//失败</span></span><br></pre></td></tr></table></figure></p><pre><code>Thanks!</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在项目中遇到一个浏览器兼容性问题。&lt;/p&gt;
&lt;p&gt;背景: 用户点击某图标，弹出提示框，2s后提示框消失。&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="http://jantc.cn/categories/web/"/>
    
    
      <category term="css" scheme="http://jantc.cn/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>聊聊分布式事务</title>
    <link href="http://jantc.cn/2017/04/18/%E8%81%8A%E8%81%8A%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    <id>http://jantc.cn/2017/04/18/聊聊分布式事务/</id>
    <published>2017-04-18T15:08:33.000Z</published>
    <updated>2020-03-23T09:10:50.383Z</updated>
    
    <content type="html"><![CDATA[<p>一、事务补偿机制 or 两阶段提交 or 三阶段提交(分布式事务服务DTS)<br>二、消息的最终一致性<br>三、等幂操作</p><blockquote><p>经典例子: eBay模式 Dubbo的分布式事务</p></blockquote><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一、事务补偿机制 or 两阶段提交 or 三阶段提交(分布式事务服务DTS)&lt;br&gt;二、消息的最终一致性&lt;br&gt;三、等幂操作&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;经典例子: eBay模式 Dubbo的分布式事务&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="java" scheme="http://jantc.cn/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>建站分享之网站优化（一）</title>
    <link href="http://jantc.cn/2017/04/16/%E5%BB%BA%E7%AB%99%E5%88%86%E4%BA%AB%E4%B9%8B%E7%BD%91%E7%AB%99%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://jantc.cn/2017/04/16/建站分享之网站优化（一）/</id>
    <published>2017-04-16T12:35:12.000Z</published>
    <updated>2020-03-23T09:10:50.376Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用-Dareboost-进行网站质量和性能分析"><a href="#使用-Dareboost-进行网站质量和性能分析" class="headerlink" title="使用 Dareboost 进行网站质量和性能分析"></a>使用 Dareboost 进行网站质量和性能分析</h3><p><a href="https://www.dareboost.com/" target="_blank" rel="noopener">Dareboost </a> 是国外一个对网站进行在线评测的平台，良心推荐。</p><p>使用方法 ：非常简单，打开后输入你的域名即可对网站作分析。</p><p>下面我根据 Dareboost 报告进行了相应的优化。</p><a id="more"></a><h4 id="1-robots-txt-file-should-be-defined"><a href="#1-robots-txt-file-should-be-defined" class="headerlink" title="1.robots.txt file should be defined"></a>1.robots.txt file should be defined</h4><p>Indicate to web crawlers which URLs should be explored on your website.</p><p>The robots.txt file</p><p>Place your robots.txt file in the root of the website. It will be interpreted by the robots in charge of your SEO. It delivers instructions to specify the pages to explore by robots, like Google bot.</p><p>Note that these directives are indicative only. A lambda robot will not be blocked by the restrictions specified by the file.</p><p>We have not detected the robots.txt file on this website, you should define one:</p><p><a href="http://jantc.cn/robots.txt">http://jantc.cn/robots.txt</a></p><p>解释：应定义robots .txt文件，向web爬虫指示应该在您的网站上浏览URL。将您的robots .txt文件放在网站的根目录下。这将由负责你的搜索引擎优化的机器人解释。它提供了指示,指定页面,以探索机器人,如谷歌机器人。</p><h5 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h5><p>在你的站点文件夹中，git bash运行下面这两行代码：</p><blockquote><p>npm install hexo-generator-sitemap@1 –save<br>npm install <a href="mailto:hexo-generator-baidu-sitemap@0.1.1" target="_blank" rel="noopener">hexo-generator-baidu-sitemap@0.1.1</a> –save</p></blockquote><p>在站点配置文件中添加代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># hexo sitemap网站地图</span><br><span class="line">sitemap:</span><br><span class="line">  path: sitemap.xml</span><br><span class="line">baidusitemap:</span><br><span class="line">  path: baidusitemap.xml</span><br></pre></td></tr></table></figure></p><p>配置成功后，hexo编译时会在hexo站点根目录生成sitemap.xml和baidusitemap.xml。其中sitemap.xml适合提交给谷歌搜素引擎，baidusitemap.xml适合提交百度搜索引擎。</p><p>其次，在站点根目录下新建一个robots.txt文件，其中添加下面的一段代码（具体网站改为你自己的网址）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># hexo robots.txt</span><br><span class="line">User-agent: *</span><br><span class="line">Allow: /</span><br><span class="line">Allow: /archives/</span><br><span class="line">Disallow: /vendors/</span><br><span class="line">Disallow: /js/</span><br><span class="line">Disallow: /css/</span><br><span class="line">Disallow: /fonts/</span><br><span class="line">Disallow: /vendors/</span><br><span class="line">Disallow: /fancybox/</span><br><span class="line">Sitemap: http:<span class="comment">//jantc.cn/sitemap.xml</span></span><br><span class="line">Sitemap: https:<span class="comment">//jantc.cn/sitemap.xml</span></span><br></pre></td></tr></table></figure></p><h4 id="2-Group-9-JavaScript-files"><a href="#2-Group-9-JavaScript-files" class="headerlink" title="2.Group 9 JavaScript files"></a>2.Group 9 JavaScript files</h4><p>Each HTTP request affects the performance of your webpage (e.g., roundtrip time and bandwidth usage).</p><p>For example, it is better to request a unique 50 kB file instead of requesting 10 files that are 5 kB in size.</p><p>How should I distribute scripts?</p><p>Distribute your scripts by integrating them directly into your HTML or grouping them in files. We recommend using the latter method to take advantage of caching mechanisms.</p><p>You should consider grouping the following resources:</p><p><a href="http://jantc.cn/lib/jquery/index.js?v=2.1.3">http://jantc.cn/lib/jquery/index.js?v=2.1.3</a><br><a href="http://jantc.cn/lib/velocity/velocity.ui.min.js?v=1.2.1">http://jantc.cn/lib/velocity/velocity.ui.min.js?v=1.2.1</a><br><a href="http://jantc.cn/lib/velocity/velocity.min.js?v=1.2.1">http://jantc.cn/lib/velocity/velocity.min.js?v=1.2.1</a><br><a href="http://jantc.cn/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7">http://jantc.cn/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7</a><br>and 5 others</p><p>解释：每个http请求都会影响网页的性能(例如,往返时间和带宽使用)。例如,最好请求一个唯一的50 kb文件,而不是请求大小为5kb的10个文件。</p><h4 id="3-38-CSS-selectors-are-duplicated"><a href="#3-38-CSS-selectors-are-duplicated" class="headerlink" title="3. 38 CSS selectors are duplicated"></a>3. 38 CSS selectors are duplicated</h4><p>Using several times the same selector for several declarative blocks within a single CSS file can affect the readability and maintainability of the code. It is also an optimization opportunity: by grouping these elements within a single rule, you will reduce the file size.</p><p>解释: 在单个CSS文件中使用多个声明块的相同选择器可以影响代码的可读性和可维护性。这也是一个优化机会:通过将这些元素分组在一个规则中,您将减少文件大小。叫我合并相同的css样式</p><h4 id="4-Explain-the-purpose-of-each-form-field"><a href="#4-Explain-the-purpose-of-each-form-field" class="headerlink" title="4.Explain the purpose of each form field"></a>4.Explain the purpose of each form field</h4><p>Clarify the purpose of each field will facilitate the user experience on your website.</p><p>A form is composed of several fields that must be the most explicit possible for the user to quickly understand their function.</p><p>解释: 明确每个字段的用途将有助于您的网站上的用户体验。表单由几个字段组成,这些字段必须是用户能够快速理解其函数最明确的。（pass）</p><p>………</p><pre><code>Thanks!</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;使用-Dareboost-进行网站质量和性能分析&quot;&gt;&lt;a href=&quot;#使用-Dareboost-进行网站质量和性能分析&quot; class=&quot;headerlink&quot; title=&quot;使用 Dareboost 进行网站质量和性能分析&quot;&gt;&lt;/a&gt;使用 Dareboost 进行网站质量和性能分析&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.dareboost.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Dareboost &lt;/a&gt; 是国外一个对网站进行在线评测的平台，良心推荐。&lt;/p&gt;
&lt;p&gt;使用方法 ：非常简单，打开后输入你的域名即可对网站作分析。&lt;/p&gt;
&lt;p&gt;下面我根据 Dareboost 报告进行了相应的优化。&lt;/p&gt;
    
    </summary>
    
      <category term="建站分享" scheme="http://jantc.cn/categories/%E5%BB%BA%E7%AB%99%E5%88%86%E4%BA%AB/"/>
    
    
  </entry>
  
  <entry>
    <title>建站分享之Github Pages + Hexo搭建博客 (三)</title>
    <link href="http://jantc.cn/2017/04/16/%E5%BB%BA%E7%AB%99%E5%88%86%E4%BA%AB%E4%B9%8BGithub%20Pages%20+%20Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%20(%E4%B8%89)/"/>
    <id>http://jantc.cn/2017/04/16/建站分享之Github Pages + Hexo搭建博客 (三)/</id>
    <published>2017-04-16T10:55:12.000Z</published>
    <updated>2020-03-23T09:10:50.373Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章主要讲一些第三方功能的配置。</p><p>主要集中了博客图片的存放，不蒜子统计，站内搜索，打赏功能</p><a id="more"></a><h4 id="博客图片存放"><a href="#博客图片存放" class="headerlink" title="博客图片存放"></a>博客图片存放</h4><p>Markdown编辑器支持插入图片，可以直接给出图片的链接，因此我们可以将图片存放在我们hexo项目的目录下，再填写对应的路径，也可以将其存放在云服务器上，然后给出链接。</p><p>在这里，我们介绍使用七牛云来进行图片托管。七牛云是国内领先的企业级云服务商,致力于打造以数据为核心的场景化PaaS服务，图片加载速度还不错，一般也不会出现图片挂掉的情况。</p><p>官网地址：<a href="http://www.qiniu.com/" target="_blank" rel="noopener">http://www.qiniu.com/</a></p><p>存储图片</p><p>（1）点击左侧菜单的对象存储<br><img src="http://ohe7ixo05.bkt.clouddn.com/2016/12/5-1.png" alt="enter image description here"><br>（2）点击上端的添加来创建存储空间<br><img src="http://ohe7ixo05.bkt.clouddn.com/2016/12/5-2.png" alt="enter image description here"><br>（3）填写好基本信息，点击确定创建<br><img src="http://ohe7ixo05.bkt.clouddn.com/2016/12/5-3.png" alt="enter image description here"><br>（4）来到新创建的存储空间，点击内容管理<br><img src="http://ohe7ixo05.bkt.clouddn.com/2016/12/5-4.png" alt="enter image description here"><br>（5）在内容管理中可以看到文件列表，点击上传文件<br><img src="http://ohe7ixo05.bkt.clouddn.com/2016/12/5-5.png" alt="enter image description here"><br>（6）可以设置上传的文件的前缀，以便进行分类管理<br><img src="http://ohe7ixo05.bkt.clouddn.com/2016/12/5-6.png" alt="enter image description here"><br>（7）点击关闭，回到内容管理页面查看上传的文件，复制图片链接<br><img src="http://ohe7ixo05.bkt.clouddn.com/2016/12/5-7.png" alt="enter image description here"><br>至此，我们就将我们博客需要的图片存储到了七牛云，然后我们只要将复制的图片链接插入到博客人文章中即可显示图片，感觉显示速度还是蛮快的。</p><h4 id="不蒜子统计"><a href="#不蒜子统计" class="headerlink" title="不蒜子统计"></a>不蒜子统计</h4><p>编辑全局配置文件中的busuanzi_count的配置项。</p><p>当enable: true时，代表开启全局开关。若site_uv、site_pv、page_pv的值均为false时，不蒜子仅作记录而不会在页面上显示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">busuanzi_count:</span><br><span class="line">  # count values only if the other configs are false</span><br><span class="line">  enable: <span class="keyword">true</span></span><br><span class="line">  # custom uv span for the whole site</span><br><span class="line">  site_uv: <span class="keyword">true</span></span><br><span class="line">  site_uv_header: &lt;i class="fa fa-user"&gt;&lt;/i&gt;    #如果使用默认的，会显示图标</span><br><span class="line">  site_uv_footer:</span><br><span class="line">  # custom pv span for the whole site</span><br><span class="line">  site_pv: <span class="keyword">true</span></span><br><span class="line">  site_pv_header: &lt;i class="fa fa-eye"&gt;&lt;/i&gt;     #如果使用默认的，会显示图标</span><br><span class="line">  site_pv_footer:</span><br><span class="line">  # custom pv span for one page only</span><br><span class="line">  page_pv: <span class="keyword">true</span></span><br><span class="line">  page_pv_header: &lt;i class="fa fa-file-o"&gt;&lt;/i&gt;  #如果使用默认的，会显示图标</span><br><span class="line">  page_pv_footer:</span><br></pre></td></tr></table></figure><p><img src="http://ohe7ixo05.bkt.clouddn.com/2016/12/5-11.png" alt="enter image description here"></p><h4 id="站内搜索"><a href="#站内搜索" class="headerlink" title="站内搜索"></a>站内搜索</h4><p>配置过了几种搜索还是发现Local Search最好用<br>（1）安装 hexo-generator-searchdb，在站点目录下执行以下命令：</p><blockquote><p>$ npm install hexo-generator-searchdb –save –</p></blockquote><p>（2）编辑全局配置文件，新增以下内容到任意位置：</p><blockquote><p>search:<br>  path: search.xml<br>  field: post<br>  format: html<br>  limit: 10000</p></blockquote><p>（3）主题配置文件中找到下面字段，开启功能<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Local search</span><br><span class="line">local_search:</span><br><span class="line">  enable: <span class="keyword">true</span></span><br></pre></td></tr></table></figure></p><p>效果如下：<br><img src="http://ooes75dyq.bkt.clouddn.com/creatblog/5.jpg" alt="enter image description here"></p><h4 id="开启打赏功能"><a href="#开启打赏功能" class="headerlink" title="开启打赏功能"></a>开启打赏功能</h4><p>next主题开启打赏功能很简单，我们只需要在全局配置文件中填入微信和支付宝收款二维码图片地址即可开启该功能。先到微信和支付宝将自己收款二维码图片保存，我们同样可以将其存在七牛云上，然后贴到下面的配置文件里。</p><blockquote><p>reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！<br>wechatpay: 微信当面付图片的url<br>alipay: 支付宝当面付图片的url<br>效果如下：<br><img src="http://ooes75dyq.bkt.clouddn.com/creatblog/6.jpg" alt="enter image description here"></p></blockquote><p>Github pages + Hexo搭建静态博客站点到这里就结束了，文章中流程部分有借鉴引用网上的资源。</p><p>后续将继续编写【<a href="http://jantc.cn/categories/建站分享/">建站分享</a>】系列。</p><pre><code>Thanks!</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章主要讲一些第三方功能的配置。&lt;/p&gt;
&lt;p&gt;主要集中了博客图片的存放，不蒜子统计，站内搜索，打赏功能&lt;/p&gt;
    
    </summary>
    
      <category term="建站分享" scheme="http://jantc.cn/categories/%E5%BB%BA%E7%AB%99%E5%88%86%E4%BA%AB/"/>
    
    
  </entry>
  
  <entry>
    <title>建站分享之Github Pages + Hexo搭建博客 (二)</title>
    <link href="http://jantc.cn/2017/04/16/%E5%BB%BA%E7%AB%99%E5%88%86%E4%BA%AB%E4%B9%8BGithub%20Pages%20+%20Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%20(%E4%BA%8C)/"/>
    <id>http://jantc.cn/2017/04/16/建站分享之Github Pages + Hexo搭建博客 (二)/</id>
    <published>2017-04-16T10:20:12.000Z</published>
    <updated>2020-03-23T09:10:50.374Z</updated>
    
    <content type="html"><![CDATA[<p>此篇文章主要分享Hexo的全局配置，以及Hexo主题的配置。</p><p>Hexo中有两份主要的配置文件，其名称都是_config.yml。其中，一份位于站点根目录下，主要包含Hexo本身的配置,我们称之为全局配置文件；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项,我们称之为主题配置文件。</p><p>hexo的官方网站：<a href="https://hexo.io/" target="_blank" rel="noopener">https://hexo.io/</a></p><a id="more"></a><h4 id="hexo的全局配置"><a href="#hexo的全局配置" class="headerlink" title="hexo的全局配置"></a>hexo的全局配置</h4><p>编辑hexo目录下的_config.yml文件，具体配置如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"># Hexo Configuration</span><br><span class="line">## Docs: https://hexo.io/docs/configuration.html</span><br><span class="line">## Source: https://github.com/hexojs/hexo/</span><br><span class="line"># Site 站点信息配置，根据自己的需要进行修改</span><br><span class="line">title: 周建川的随想录    #站点名，会在浏览器页面标签左上角显示</span><br><span class="line">subtitle: 因为懂得，所以慈悲。fe  #副标题</span><br><span class="line">description: Humble to the dust and then out of the flowerse  #对站点的描述，给搜索引擎看的，可以自定义</span><br><span class="line">author: Jant  #网站作者</span><br><span class="line">language: default  #网站语言 default是英文 zh-Hans是中文</span><br><span class="line">timezone: Asia/Shanghai  #时区</span><br><span class="line">avatar: /images/logo.jpg  #网站logo，会在浏览器页面标签左上角显示</span><br><span class="line"># URL 博客地址,与申请的GitHub一致</span><br><span class="line">## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'</span><br><span class="line">url: https:<span class="comment">//fzy-line.github.io/</span></span><br><span class="line">root: /</span><br><span class="line">#博客链接格式</span><br><span class="line">permalink: :year/:month/:day/:title/ </span><br><span class="line">permalink_defaults:</span><br><span class="line"># Directory  #目录设置，一般不修改</span><br><span class="line">source_dir: source  #资源文件夹，放在里面的文件会上传到github中</span><br><span class="line">public_dir: public  #公共文件夹，存放生成的静态文件</span><br><span class="line">tag_dir: tags  #标签文件夹，默认是tags。实际存放在source/tags中。</span><br><span class="line">archive_dir: archives  #档案文件夹，默认是archives。</span><br><span class="line">category_dir: categories  #分类文件夹，默认是categories。实际存放在source/categories中。</span><br><span class="line">code_dir: downloads/code  #代码文件夹，默认是downloads/code</span><br><span class="line">i18n_dir: :lang  #国际化文件夹，默认跟language相同</span><br><span class="line">skip_render:  #跳过指定文件的渲染，您可使用 glob 来配置路径。</span><br><span class="line"># Writing  这是文章布局、写作格式的定义，一般不修改</span><br><span class="line">new_post_name: :title.md # File name of new posts</span><br><span class="line">default_layout: post</span><br><span class="line">titlecase: false # Transform title into titlecase</span><br><span class="line">external_link: true # Open external links in new tab</span><br><span class="line">filename_case: <span class="number">0</span></span><br><span class="line">render_drafts: <span class="keyword">false</span></span><br><span class="line">post_asset_folder: <span class="keyword">false</span></span><br><span class="line">relative_link: <span class="keyword">false</span></span><br><span class="line">future: <span class="keyword">true</span></span><br><span class="line">highlight:</span><br><span class="line">  enable: <span class="keyword">true</span></span><br><span class="line">  line_number: <span class="keyword">true</span></span><br><span class="line">  auto_detect: <span class="keyword">false</span></span><br><span class="line">  tab_replace:</span><br><span class="line"># Category &amp; Tag  #分类和标签，一般不修改</span><br><span class="line">default_category: uncategorized</span><br><span class="line">category_map:</span><br><span class="line">tag_map:</span><br><span class="line"># Date / Time format  #日期、时间格式，一般不修改</span><br><span class="line">## Hexo uses Moment.js to parse and display date</span><br><span class="line">## You can customize the date format as defined in</span><br><span class="line">## http://momentjs.com/docs/#/displaying/format/</span><br><span class="line">date_format: YYYY-MM-DD </span><br><span class="line">time_format: HH:mm:ss</span><br><span class="line"># Pagination  #可根据自己需要修改</span><br><span class="line">## Set per_page to 0 to disable pagination</span><br><span class="line">per_page: 6  #分页，每页文章数量</span><br><span class="line">pagination_dir: page</span><br><span class="line"># Extensions  #扩展</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: next  #博客主题</span><br><span class="line">  </span><br><span class="line"># Deployment 这里配置站点部署到Github，上一节中已经讲过</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git<span class="meta">@github</span>.com:你的Github用户名.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></p><h4 id="再次声明"><a href="#再次声明" class="headerlink" title="再次声明"></a>再次声明</h4><font color="red">所有配置都是字段后面的冒号是英文的，而且要在后面加一个空格再写入值</font><h4 id="Hexo主题选择"><a href="#Hexo主题选择" class="headerlink" title="Hexo主题选择"></a>Hexo主题选择</h4><p>Hexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 themes 目录下， 然后修改下配置文件即可。</p><p>hexo官方主题下载地址：<a href="https://hexo.io/themes/，里面有多种多样的主题模板供大家选择。" target="_blank" rel="noopener">https://hexo.io/themes/，里面有多种多样的主题模板供大家选择。</a></p><p>这里我选择的是Next主题，next主题的官网，有很详细的配置文档：<a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">http://theme-next.iissnan.com/</a></p><p>后续的讲解也都以Next主题为准。</p><p>next下载地址：<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next</a></p><p><img src="http://ohe7ixo05.bkt.clouddn.com/2016/12/2-1.png" alt="enter image description here"></p><p>到Gtihub下载此主题后解压，打开可以看到里面很多主题相关的文件，我们将此文件夹改名为next，然后将它复制到站点目录的/themes/目录下。</p><p>我们的themes文件夹里可以放很多主题的文件夹，但是实际上我们的网站采用哪一个主题，这是需要我们进行配置的，打开编辑全局配置文件，找到下面的内容：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Extensions  #扩展</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: next  #博客主题，默认是landscape</span><br></pre></td></tr></table></figure><p>在theme字段这里填上你下载的主题的文件夹的名字，例如我们使用next主题就填上next。这样配置文件就和我们的主题文件关联起来了。</p><p>（1）配置基本信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 网站图标，将其放在hexo站点/source/目录下</span><br><span class="line">favicon: /logo.jpg</span><br><span class="line"># 关键词，例如下面是我写的</span><br><span class="line">keywords: <span class="string">"Python,Life,Android"</span></span><br><span class="line"># 网站建立时间，显示在页面底部</span><br><span class="line">since: <span class="number">2016</span></span><br><span class="line"># 网站版权声明，显示在页面底部</span><br><span class="line">copyright: <span class="keyword">true</span></span><br></pre></td></tr></table></figure><p>（2）选择外观样式<br>目前 NexT 支持三种 Scheme，他们是：</p><p>Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白</p><p>Mist - Muse 的紧凑版本，整洁有序的单栏外观</p><p>Pisces - 双栏 Scheme，小家碧玉似的清新</p><p><img src="http://ohe7ixo05.bkt.clouddn.com/2016/12/2-2.png" alt="enter image description here"></p><p>我是用的Mist</p><p>找到主题配置文件的如下三行，其中#号表示注释，要启用哪一种样式就把#号去掉即可。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Schemes</span><br><span class="line">#scheme: Muse</span><br><span class="line">scheme: Mist</span><br><span class="line">#scheme: Pisces</span><br></pre></td></tr></table></figure><p>（3）设置菜单<br>菜单内容的设置格式是：item name: link。其中 item name 是一个名称，这个名称并不直接显示在页面上，它将用于匹配图标以及翻译。<br>menu:<br>  home: /<br>  archives: /archives<br>  categories: /categories<br>  tags: /tags<br>  about: /about</p><p>  #sitemap: /sitemap.xml</p><p>  #commonweal: /404.html</p><p><code>直接显示在页面上对应导航栏的是在主题-languages-defalut.yml里面的menu</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">menu_icons:</span><br><span class="line">  enable: <span class="keyword">true</span></span><br><span class="line">  #KeyMapsToMenuItemKey: NameOfTheIconFromFontAwesome</span><br><span class="line">  home: home</span><br><span class="line">  about: user</span><br><span class="line">  categories: th</span><br><span class="line">  schedule: calendar</span><br><span class="line">  tags: tags</span><br><span class="line">  archives: archive</span><br><span class="line">  sitemap: sitemap</span><br><span class="line">  commonweal: heartbeat</span><br></pre></td></tr></table></figure><p>menu_icons其中 前面的字段 与上一步所配置的菜单名字对应，后面的值 是 Font Awesome 图标的 名字。而 enable 可用于控制是否显示图标，你可以设置成 false 来去掉图标。</p><h4 id="本地测试"><a href="#本地测试" class="headerlink" title="本地测试"></a>本地测试</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean #用于清除缓存</span><br><span class="line">$ hexo generate #生成静态网页</span><br><span class="line">$ hexo server #开启本地预览</span><br></pre></td></tr></table></figure><p>访问：<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 查看效果，如下图：<br><img src="http://ohe7ixo05.bkt.clouddn.com/2016/12/2-3.png" alt="enter image description here"></p><h5 id="这里遇到的几个问题集中一下"><a href="#这里遇到的几个问题集中一下" class="headerlink" title="这里遇到的几个问题集中一下"></a>这里遇到的几个问题集中一下</h5><p>到这里会发现点击左侧菜单的分类、标签和关于会提示找不到页面。</p><p>这是因为我们只是创建了菜单，还没有创建相应的页面。 </p><p>新建页面的hexo命令是：<br><code>$ hexo new page &quot;pageName&quot;</code><br>这里我们给打不开的页面都生成一下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo <span class="keyword">new</span> page <span class="string">'categories'</span></span><br><span class="line">$ hexo <span class="keyword">new</span> page <span class="string">'tags'</span></span><br><span class="line">$ hexo <span class="keyword">new</span> page <span class="string">'about'</span></span><br></pre></td></tr></table></figure></p><p>分别执行完这三条命令后，我们会发现站点目录下的/source/目录下多了三个文件夹：categories，tags，about，每个文件夹里面都会生成一个index.md文件，如下：</p><p>默认都只会生成title和date字段，我们要为其添加上type字段，并赋值。</p><p><strong>注意：博客文章的抬头信息中每个字段后面的冒号是英文格式的，而且其后要加一个空格再写值</strong></p><p>categories下的index.md：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: <span class="number">2016</span>-<span class="number">12</span>-<span class="number">02</span> <span class="number">23</span>:<span class="number">28</span>:<span class="number">27</span></span><br><span class="line">type: categories</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><p>tags下的index.md：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: <span class="number">2016</span>-<span class="number">12</span>-<span class="number">02</span> <span class="number">23</span>:<span class="number">31</span>:<span class="number">23</span></span><br><span class="line">type: tags</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><p>about下的index.md：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: about</span><br><span class="line">date: <span class="number">2016</span>-<span class="number">12</span>-<span class="number">02</span> <span class="number">23</span>:<span class="number">31</span>:<span class="number">23</span></span><br><span class="line">type: about</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><p>这样我们的这几个页面也就没有问题了。至此，基本的配置也就完成了，接下来介绍如何写博客与发布博客。</p><h4 id="如何写文章"><a href="#如何写文章" class="headerlink" title="如何写文章"></a>如何写文章</h4><p>实例：</p><p>新建博客《我的第一篇博客》</p><p><code>1$ hexo new &quot;我的第一篇博客&quot;</code></p><p>到站点目录下的/source/_posts/目录下可以看到生成了名为：我的第一篇博客.md的文件，这是Markdown格式的文件，可以用sublime text3或者notepad++等编辑器打开，也可以下载一个MarkdownPad来编辑Markdown文件。</p><p>如果你没有使用过Markdown编辑器，那请你自己去学习一下Markdown语法。</p><p>Markdown 语法说明(简体中文版)：<a href="http://www.appinn.com/markdown/" target="_blank" rel="noopener">http://www.appinn.com/markdown/</a></p><p>Hexo默认新建的文章抬头已有title、date、tags等属性，可能缺乏categories和meta标签，想要指定目录就需要添加categories属性，而meta标签则是为了便于搜索引擎的收录。如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 我的第一篇博客</span><br><span class="line">date: <span class="number">2017</span>-<span class="number">04</span>-<span class="number">15</span> <span class="number">00</span>:<span class="number">25</span>:<span class="number">25</span></span><br><span class="line">tags: [first]</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><p>tags字段是文章的标签，可以指定标签也可以不指定，如果要指定多个标签需要这样做：<br><code>tags: [java,c++]</code><br>我们可以添加上categories字段，对博客进行分类管理，然后点击主页左侧菜单的分类就可看到具体的分类。例如：<br><code>categories: life</code></p><h4 id="首页文章的阅读全文按钮是怎么实现的"><a href="#首页文章的阅读全文按钮是怎么实现的" class="headerlink" title="首页文章的阅读全文按钮是怎么实现的"></a>首页文章的阅读全文按钮是怎么实现的</h4><p>很简单，只需要在文章内容你指定位置插入<!--more--></p><p>那么首页文章只会展示more上面的内容。</p><h4 id="有的人很好奇我们本地是-md结尾的文件，发布到github上却不是这个格式"><a href="#有的人很好奇我们本地是-md结尾的文件，发布到github上却不是这个格式" class="headerlink" title="有的人很好奇我们本地是.md结尾的文件，发布到github上却不是这个格式"></a>有的人很好奇我们本地是.md结尾的文件，发布到github上却不是这个格式</h4><p>我们博客文章的编写都是Markdown文件，但是发布到github上的其实是html文件，将Markdown转换成html这个工作我们只要输入hexo generate命令即可，hexo会帮我们完成转换。</p><h4 id="再讲下每次写完文章的发布流程"><a href="#再讲下每次写完文章的发布流程" class="headerlink" title="再讲下每次写完文章的发布流程"></a>再讲下每次写完文章的发布流程</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean  #清除缓存 网页正常情况下可以忽略此条命令</span><br><span class="line">$ hexo generate  #生成静态页面至public目录</span><br><span class="line"><span class="comment">//写好之后可以现在本地预览，确定无误之后再部署到Github上。 localhost:4000</span></span><br><span class="line">$ hexo server  #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）</span><br><span class="line">$ hexo deploy  #将.deploy目录部署到GitHub</span><br></pre></td></tr></table></figure><p>hexo generate 可以简写 hexo g<br>hexo server 可以简写 hexo s</p><p>恭喜你到这里,你的个人博客就全部搭建成功了。</p><p>如何引入评论功能，域名更换与解析，文章与网站计数功能等等第三方功能。</p><p>将在下次分享。</p><pre><code>Thanks！</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此篇文章主要分享Hexo的全局配置，以及Hexo主题的配置。&lt;/p&gt;
&lt;p&gt;Hexo中有两份主要的配置文件，其名称都是_config.yml。其中，一份位于站点根目录下，主要包含Hexo本身的配置,我们称之为全局配置文件；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项,我们称之为主题配置文件。&lt;/p&gt;
&lt;p&gt;hexo的官方网站：&lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://hexo.io/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="建站分享" scheme="http://jantc.cn/categories/%E5%BB%BA%E7%AB%99%E5%88%86%E4%BA%AB/"/>
    
    
  </entry>
  
  <entry>
    <title>建站分享之Github Pages + Hexo搭建博客 (一)</title>
    <link href="http://jantc.cn/2017/04/16/%E5%BB%BA%E7%AB%99%E5%88%86%E4%BA%AB%E4%B9%8BGithub%20Pages%20+%20Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%20(%E4%B8%80)/"/>
    <id>http://jantc.cn/2017/04/16/建站分享之Github Pages + Hexo搭建博客 (一)/</id>
    <published>2017-04-16T09:12:12.000Z</published>
    <updated>2020-03-23T09:10:50.372Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在经受CSDN辣眼睛的排版后，就一直在想要是能有一个自己的博客就好了。</p><p>大多数人会经历以下三个阶段 :</p><p>（1）第一阶段，刚接触Blog，觉得很新鲜，试着选择一个免费空间来写。</p><p>（2）第二阶段，发现免费的空间太多限制，不能让我们肆意的发挥，于是选择购买域名和空间建站</p><p>（3）第三阶段，觉得独立博客管理起来又太麻烦，最好在保留控制权的前提下，让别人管，自己只写。</p><p>我最开始也是在CSDN上写自己的文章，现在整体搬迁到Github 上来，中途遇到很多难题，不断Google，不断学习，我想我大概就是这么一个爱折腾的人吧。</p><a id="more"></a><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>首先介绍一下Github Pages ：它提供了300M的免费空间，并且稳定可靠。</p><p>在这样一个前提下，我们自然而且就能够放心的将blog搭建在上面。</p><p>作为一个程序员，应该学会使用Git来管理项目，同时应当学会在github上寻找我们需要的资源fork –&gt;forking</p><font color="red"><strong>Github是趋势，做it的人应今早融入这个大环境</strong></font><h4 id="Github注册与配置说明"><a href="#Github注册与配置说明" class="headerlink" title="Github注册与配置说明"></a>Github注册与配置说明</h4><h5 id="新建一个仓库"><a href="#新建一个仓库" class="headerlink" title="新建一个仓库"></a>新建一个仓库</h5><p><img src="http://ooes75dyq.bkt.clouddn.com/creatblog/1.jpg" alt="enter image description here"></p><p>yourusername.github.io 以后就是你的域名了。</p><p>建好后进入你的仓库，点击settings<br><img src="http://ooes75dyq.bkt.clouddn.com/creatblog/2.jpg" alt="enter image description here"></p><p>找到Github Pages栏目，点击选择一个主题<br><img src="http://ooes75dyq.bkt.clouddn.com/creatblog/3.jpg" alt="enter image description here"></p><p>选择主题<br><img src="http://ooes75dyq.bkt.clouddn.com/creatblog/4.jpg" alt="enter image description here"></p><p>主题生效后，我们的github pages也就设置完毕了，然后你现在在地址栏访问yourusername.github.io就可以测试刚才建好的站点。</p><h4 id="下载Git-、Nodes-js"><a href="#下载Git-、Nodes-js" class="headerlink" title="下载Git 、Nodes.js"></a>下载Git 、Nodes.js</h4><h5 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h5><p>选择你自己的操作系统版本下载 <a href="https://git-scm.com/download/win" target="_blank" rel="noopener">Git下载地址</a> </p><p>安装并配置环境变量（你的Git安装目录）</p><p>可以用下面的命令测试Git是否安装成功：</p><p><code>git --version</code> </p><p>添加SSH-key到刚才创建的仓库中，这样才能够提交代码到仓库。</p><p>（1）先检查是否安装有SSH KEY</p><p>打开git bash，输入cd ~/.ssh 或cd .ssh</p><p>如果没有则提示： No such file or directory</p><p>如果有则进入~/.ssh路径下（ls查看当前路径文件，rm * 删除所有文件）</p><p>（2）配置SSH KEY</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~  #保证当前路径在”~”下</span><br><span class="line">$ ssh-keygen -t rsa -C "这里填写你的邮箱地址"</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/c/Users/xxxx_000/.ssh/id_rsa):   #不填直接回车</span><br><span class="line">Enter passphrase (empty for no passphrase):   #输入密码（可以为空）</span><br><span class="line">Enter same passphrase again:   #再次确认密码（可以为空）</span><br><span class="line">Your identification has been saved in /c/Users/xxxx_000/.ssh/id_rsa.   #生成的密钥</span><br><span class="line">Your public key has been saved in /c/Users/xxxx_000/.ssh/id_rsa.pub.  #生成的公钥</span><br><span class="line">The key fingerprint is:</span><br><span class="line">e3:51:33:xx:xx:xx:xx:xxx:61:28:83:e2:81 xxxxxx@yy.com</span><br></pre></td></tr></table></figure><p>到这里SSH KEY 已经生成完毕，其存放路径为：c:/Users/你电脑的用户名/.ssh/下。</p><p>（3）在Github 配置SSH-KEY</p><p>登录GitHub系统；点击右上角账号头像的“▼”→Settings→SSH kyes→Add SSH key，Title自定义，复制id_rsa.pub的公钥内容到GitHub中Add an SSH key的key输入框，最后“Add Key”。</p><p>（4）配置本地账户<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name “your_username”  #设置用户名</span><br><span class="line">$ git config --global user.email “your_registered_github_Email” </span><br><span class="line">#设置邮箱地址(建议用注册giuhub的邮箱)</span><br></pre></td></tr></table></figure></p><h5 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h5><p>根据电脑操作系统版本下载： <a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">Node.js下载地址</a></p><p>测试是否安装成功</p><p><code>node -v</code> 如果提示没有找到此命令就去配置node.js的环境变量</p><h5 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h5><p>hexo是基于node.js的静态博客，官网也是放在Github上面的。ps:不用单独下载hexo</p><h5 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h5><p>选择一个文件夹，用来存放你的博客所有文件。在此文件夹下右键打开Git Bash输入以下命令进行安装</p><p><code>$ npm install -g hexo-cli</code></p><p>初始化hexo</p><p><code>$ hexo init hexo</code></p><p>这里会将Github上的hexo项目clone下来，得到hexo文件夹。</p><p>初始化成功后会在最后打印一行：INFO Start blogging with Hexo!</p><h5 id="配置hexo"><a href="#配置hexo" class="headerlink" title="配置hexo"></a>配置hexo</h5><p>（1）进入到hexo文件 （2）安装依赖文件 （3）部署形成文件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd hexo</span><br><span class="line">$ npm install</span><br><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></p><p>（4）本地测试</p><p><code>$ hexo server</code><br>在浏览器输入：<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 即可访问到我们搭建好的hexo站点。<br><img src="http://ohe7ixo05.bkt.clouddn.com/2016/11/30-7.png" alt="enter image description here"></p><h4 id="重点"><a href="#重点" class="headerlink" title="重点"></a><font color="red">重点</font></h4><h5 id="将本地hexo项目托管到Github"><a href="#将本地hexo项目托管到Github" class="headerlink" title="将本地hexo项目托管到Github"></a>将本地hexo项目托管到Github</h5><p>修改全局配置文件_config.yml</p><p>说明： hexo文件夹下一个_config.yml，我们称之为全局配置文件，在每个主题文件夹内还会有一个_config.yml文件，我们称之为主题配置文件。</p><p>用Editplus或者notepad++编辑器打开hexo文件夹下的_config.yml文件。</p><p>注意：配置文件中每个字段后面的冒号是英文格式的，且在其后要加一个空格再写值</p><p>一定记住这是规范！！！  <font color="red">key:空格value</font></p><p>编辑最后面的deploy属性，加入代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git   </span><br><span class="line">  repository: https:<span class="comment">//github.com/你的Github用户名/你的Github用户名.github.io.git</span></span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></p><p><font color="red">注意一定要按照这个格式，deploy下面三个属性前面有2个空格<font></font></font></p><h5 id="安装hexo-deployer-git插件"><a href="#安装hexo-deployer-git插件" class="headerlink" title="安装hexo-deployer-git插件"></a>安装hexo-deployer-git插件</h5><p>安装这个插件可以快速帮助我们把代码托管到github</p><p><code>$ npm install hexo-deployer-git --save</code></p><p>部署到Github上的方法：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean  #清除缓存 网页正常情况下可以忽略此条命令</span><br><span class="line">$ hexo generator  #生成静态页面至public目录</span><br><span class="line">$ hexo deploy  #将.deploy目录部署到GitHub</span><br></pre></td></tr></table></figure><p>部署成功后会显示<br>INFO  Deploy done: git</p><p>到这里恭喜你，你的hexo项目基本上就搭建成功了。通过yourusername.github.io就可以访问hexo项目了。</p><p>下篇文章讲解hexo主题的配置。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在经受CSDN辣眼睛的排版后，就一直在想要是能有一个自己的博客就好了。&lt;/p&gt;
&lt;p&gt;大多数人会经历以下三个阶段 :&lt;/p&gt;
&lt;p&gt;（1）第一阶段，刚接触Blog，觉得很新鲜，试着选择一个免费空间来写。&lt;/p&gt;
&lt;p&gt;（2）第二阶段，发现免费的空间太多限制，不能让我们肆意的发挥，于是选择购买域名和空间建站&lt;/p&gt;
&lt;p&gt;（3）第三阶段，觉得独立博客管理起来又太麻烦，最好在保留控制权的前提下，让别人管，自己只写。&lt;/p&gt;
&lt;p&gt;我最开始也是在CSDN上写自己的文章，现在整体搬迁到Github 上来，中途遇到很多难题，不断Google，不断学习，我想我大概就是这么一个爱折腾的人吧。&lt;/p&gt;
    
    </summary>
    
      <category term="建站分享" scheme="http://jantc.cn/categories/%E5%BB%BA%E7%AB%99%E5%88%86%E4%BA%AB/"/>
    
    
  </entry>
  
  <entry>
    <title>建站分享之添加留言板</title>
    <link href="http://jantc.cn/2017/04/16/%E5%BB%BA%E7%AB%99%E5%88%86%E4%BA%AB%E4%B9%8B%E6%B7%BB%E5%8A%A0%E7%95%99%E8%A8%80%E6%9D%BF/"/>
    <id>http://jantc.cn/2017/04/16/建站分享之添加留言板/</id>
    <published>2017-04-16T08:47:26.000Z</published>
    <updated>2020-03-23T09:10:50.375Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>留言功能会让自己的博客变得更人性化，同时也能够互动，相互沟通交流心得。</p></blockquote><p><strong>下面分享如何给心爱的blog加入留言功能…</strong></p><a id="more"></a><p>一. 首先进入到blog的根目录</p><p><code>hexo new page &quot;comment&quot;</code></p><p>二. 在主题的配置文件中添加comment</p><p>Next主题：_config.yml<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: /</span><br><span class="line">  archives: /archives</span><br><span class="line">  categories: /categories</span><br><span class="line">  tags: /tags</span><br><span class="line">  about: /about</span><br><span class="line">  comment : /comment</span><br></pre></td></tr></table></figure></p><p>三. 在blog选择的languages中新增comment</p><p>Next-languages-default.yml (我的blog用的是英文,所以是这个,中文是这zh-Hans.yml)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: Home</span><br><span class="line">  archives: Archives</span><br><span class="line">  categories: Categories</span><br><span class="line">  tags: Tags</span><br><span class="line">  about: About</span><br><span class="line">  comment: Comment</span><br></pre></td></tr></table></figure></p><p>然后再接入你的评论系统就ok了。我的是<font color="red"><strong>网易云跟帖</strong></font>，下次分享如何接入。</p><pre><code>Thanks！</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;留言功能会让自己的博客变得更人性化，同时也能够互动，相互沟通交流心得。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;下面分享如何给心爱的blog加入留言功能…&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="建站分享" scheme="http://jantc.cn/categories/%E5%BB%BA%E7%AB%99%E5%88%86%E4%BA%AB/"/>
    
    
  </entry>
  
  <entry>
    <title>生产-消费者设计模式的两种实现方式</title>
    <link href="http://jantc.cn/2017/04/15/%E7%94%9F%E4%BA%A7-%E6%B6%88%E8%B4%B9%E8%80%85%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"/>
    <id>http://jantc.cn/2017/04/15/生产-消费者设计模式的两种实现方式/</id>
    <published>2017-04-15T10:31:26.000Z</published>
    <updated>2020-03-23T09:10:50.379Z</updated>
    
    <content type="html"><![CDATA[<p>这里暂时介绍两种。<br>第一种是wait()—–notifyAll()<br>第二种是用到了LinkedBlockingQueue(原理同上，可以点源码详细学习)</p><a id="more"></a><p>第一种:<br><strong>Storage</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Storage</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SIZE = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Object&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Storage<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(list.size()+<span class="number">1</span>&gt;MAX_SIZE)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"此时库存量为:"</span>+list.size()+<span class="string">"已达到最大容量！不能进行生产操作"</span>);</span><br><span class="line">                    <span class="keyword">try</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        Storage<span class="class">.<span class="keyword">class</span>.<span class="title">wait</span>()</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">                    &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    list.add(<span class="keyword">new</span> Object());</span><br><span class="line">                    System.out.println(<span class="string">"已经生产了1个产品,现在库存量为"</span>+list.size());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Storage<span class="class">.<span class="keyword">class</span>.<span class="title">notifyAll</span>()</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Storage<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(list.size()==<span class="number">0</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"此时库存量为0,不能进行消费操作"</span>);</span><br><span class="line">                    <span class="keyword">try</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        Storage<span class="class">.<span class="keyword">class</span>.<span class="title">wait</span>()</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">                    &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    list.remove();</span><br><span class="line">                    System.out.println(<span class="string">"已经消费了1个产品,现在库存量为"</span>+list.size());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Storage<span class="class">.<span class="keyword">class</span>.<span class="title">notifyAll</span>()</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMAX_SIZE</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> MAX_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LinkedList&lt;Object&gt; <span class="title">getList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setList</span><span class="params">(LinkedList&lt;Object&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Producer:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 每次生产的产品数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所在放置的仓库</span></span><br><span class="line">    <span class="keyword">private</span> Storage storage;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数，设置仓库</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(Storage storage)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.storage = storage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程run函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        produce(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用仓库Storage的生产函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        storage.produce(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get/set方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNum</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Storage <span class="title">getStorage</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> storage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStorage</span><span class="params">(Storage storage)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.storage = storage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Consumer：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 每次消费的产品数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所在放置的仓库</span></span><br><span class="line">    <span class="keyword">private</span> Storage storage;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数，设置仓库</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(Storage storage)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.storage = storage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程run函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        consume(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用仓库Storage的生产函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        storage.consume(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get/set方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNum</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Storage <span class="title">getStorage</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> storage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStorage</span><span class="params">(Storage storage)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.storage = storage;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>Test:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 仓库对象</span></span><br><span class="line">        Storage storage = <span class="keyword">new</span> Storage();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生产者对象</span></span><br><span class="line">        Producer p1 = <span class="keyword">new</span> Producer(storage);</span><br><span class="line">        Producer p2 = <span class="keyword">new</span> Producer(storage);</span><br><span class="line">        Producer p3 = <span class="keyword">new</span> Producer(storage);</span><br><span class="line">        Producer p4 = <span class="keyword">new</span> Producer(storage);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费者对象</span></span><br><span class="line">        Consumer c1 = <span class="keyword">new</span> Consumer(storage);</span><br><span class="line">        Consumer c2 = <span class="keyword">new</span> Consumer(storage);</span><br><span class="line">        Consumer c3 = <span class="keyword">new</span> Consumer(storage);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置生产者产品生产数量</span></span><br><span class="line">        p1.setNum(<span class="number">10</span>);</span><br><span class="line">        p2.setNum(<span class="number">10</span>);</span><br><span class="line">        p3.setNum(<span class="number">10</span>);</span><br><span class="line">        p4.setNum(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置消费者产品消费数量</span></span><br><span class="line">        c1.setNum(<span class="number">50</span>);</span><br><span class="line">        c2.setNum(<span class="number">20</span>);</span><br><span class="line">        c3.setNum(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程开始执行</span></span><br><span class="line">        c1.start();</span><br><span class="line">        c2.start();</span><br><span class="line">        c3.start();</span><br><span class="line">        p1.start();</span><br><span class="line">        p2.start();</span><br><span class="line">        p3.start();</span><br><span class="line">        p4.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试结果:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">Thread[Thread-<span class="number">4</span>,<span class="number">5</span>,main]此时库存量为<span class="number">0</span>,不能进行消费操作</span><br><span class="line">Thread[Thread-<span class="number">2</span>,<span class="number">5</span>,main]已经生产了<span class="number">1</span>个产品,现在库存量为<span class="number">1</span></span><br><span class="line">Thread[Thread-<span class="number">2</span>,<span class="number">5</span>,main]已经生产了<span class="number">1</span>个产品,现在库存量为<span class="number">2</span></span><br><span class="line">Thread[Thread-<span class="number">2</span>,<span class="number">5</span>,main]已经生产了<span class="number">1</span>个产品,现在库存量为<span class="number">3</span></span><br><span class="line">Thread[Thread-<span class="number">2</span>,<span class="number">5</span>,main]已经生产了<span class="number">1</span>个产品,现在库存量为<span class="number">4</span></span><br><span class="line">Thread[Thread-<span class="number">2</span>,<span class="number">5</span>,main]已经生产了<span class="number">1</span>个产品,现在库存量为<span class="number">5</span></span><br><span class="line">Thread[Thread-<span class="number">2</span>,<span class="number">5</span>,main]已经生产了<span class="number">1</span>个产品,现在库存量为<span class="number">6</span></span><br><span class="line">Thread[Thread-<span class="number">2</span>,<span class="number">5</span>,main]已经生产了<span class="number">1</span>个产品,现在库存量为<span class="number">7</span></span><br><span class="line">Thread[Thread-<span class="number">2</span>,<span class="number">5</span>,main]已经生产了<span class="number">1</span>个产品,现在库存量为<span class="number">8</span></span><br><span class="line">Thread[Thread-<span class="number">2</span>,<span class="number">5</span>,main]已经生产了<span class="number">1</span>个产品,现在库存量为<span class="number">9</span></span><br><span class="line">Thread[Thread-<span class="number">2</span>,<span class="number">5</span>,main]已经生产了<span class="number">1</span>个产品,现在库存量为<span class="number">10</span></span><br><span class="line">Thread[Thread-<span class="number">0</span>,<span class="number">5</span>,main]已经生产了<span class="number">1</span>个产品,现在库存量为<span class="number">11</span></span><br><span class="line">Thread[Thread-<span class="number">0</span>,<span class="number">5</span>,main]已经生产了<span class="number">1</span>个产品,现在库存量为<span class="number">12</span></span><br><span class="line">Thread[Thread-<span class="number">0</span>,<span class="number">5</span>,main]已经生产了<span class="number">1</span>个产品,现在库存量为<span class="number">13</span></span><br><span class="line">Thread[Thread-<span class="number">0</span>,<span class="number">5</span>,main]已经生产了<span class="number">1</span>个产品,现在库存量为<span class="number">14</span></span><br><span class="line">Thread[Thread-<span class="number">0</span>,<span class="number">5</span>,main]已经生产了<span class="number">1</span>个产品,现在库存量为<span class="number">15</span></span><br><span class="line">Thread[Thread-<span class="number">0</span>,<span class="number">5</span>,main]已经生产了<span class="number">1</span>个产品,现在库存量为<span class="number">16</span></span><br><span class="line">Thread[Thread-<span class="number">0</span>,<span class="number">5</span>,main]已经生产了<span class="number">1</span>个产品,现在库存量为<span class="number">17</span></span><br><span class="line">Thread[Thread-<span class="number">0</span>,<span class="number">5</span>,main]已经生产了<span class="number">1</span>个产品,现在库存量为<span class="number">18</span></span><br><span class="line">Thread[Thread-<span class="number">0</span>,<span class="number">5</span>,main]已经生产了<span class="number">1</span>个产品,现在库存量为<span class="number">19</span></span><br><span class="line">Thread[Thread-<span class="number">0</span>,<span class="number">5</span>,main]已经生产了<span class="number">1</span>个产品,现在库存量为<span class="number">20</span></span><br><span class="line">Thread[Thread-<span class="number">3</span>,<span class="number">5</span>,main]已经生产了<span class="number">1</span>个产品,现在库存量为<span class="number">21</span></span><br><span class="line">Thread[Thread-<span class="number">3</span>,<span class="number">5</span>,main]已经生产了<span class="number">1</span>个产品,现在库存量为<span class="number">22</span></span><br><span class="line">Thread[Thread-<span class="number">3</span>,<span class="number">5</span>,main]已经生产了<span class="number">1</span>个产品,现在库存量为<span class="number">23</span></span><br><span class="line">Thread[Thread-<span class="number">3</span>,<span class="number">5</span>,main]已经生产了<span class="number">1</span>个产品,现在库存量为<span class="number">24</span></span><br><span class="line">Thread[Thread-<span class="number">3</span>,<span class="number">5</span>,main]已经生产了<span class="number">1</span>个产品,现在库存量为<span class="number">25</span></span><br><span class="line">Thread[Thread-<span class="number">3</span>,<span class="number">5</span>,main]已经生产了<span class="number">1</span>个产品,现在库存量为<span class="number">26</span></span><br><span class="line">Thread[Thread-<span class="number">3</span>,<span class="number">5</span>,main]已经生产了<span class="number">1</span>个产品,现在库存量为<span class="number">27</span></span><br><span class="line">Thread[Thread-<span class="number">3</span>,<span class="number">5</span>,main]已经生产了<span class="number">1</span>个产品,现在库存量为<span class="number">28</span></span><br><span class="line">Thread[Thread-<span class="number">3</span>,<span class="number">5</span>,main]已经生产了<span class="number">1</span>个产品,现在库存量为<span class="number">29</span></span><br><span class="line">Thread[Thread-<span class="number">3</span>,<span class="number">5</span>,main]已经生产了<span class="number">1</span>个产品,现在库存量为<span class="number">30</span></span><br><span class="line">Thread[Thread-<span class="number">6</span>,<span class="number">5</span>,main]已经消费了<span class="number">1</span>个产品,现在库存量为<span class="number">29</span></span><br><span class="line">Thread[Thread-<span class="number">6</span>,<span class="number">5</span>,main]已经消费了<span class="number">1</span>个产品,现在库存量为<span class="number">28</span></span><br><span class="line">Thread[Thread-<span class="number">6</span>,<span class="number">5</span>,main]已经消费了<span class="number">1</span>个产品,现在库存量为<span class="number">27</span></span><br><span class="line">Thread[Thread-<span class="number">6</span>,<span class="number">5</span>,main]已经消费了<span class="number">1</span>个产品,现在库存量为<span class="number">26</span></span><br><span class="line">Thread[Thread-<span class="number">6</span>,<span class="number">5</span>,main]已经消费了<span class="number">1</span>个产品,现在库存量为<span class="number">25</span></span><br><span class="line">Thread[Thread-<span class="number">6</span>,<span class="number">5</span>,main]已经消费了<span class="number">1</span>个产品,现在库存量为<span class="number">24</span></span><br><span class="line">Thread[Thread-<span class="number">6</span>,<span class="number">5</span>,main]已经消费了<span class="number">1</span>个产品,现在库存量为<span class="number">23</span></span><br><span class="line">Thread[Thread-<span class="number">6</span>,<span class="number">5</span>,main]已经消费了<span class="number">1</span>个产品,现在库存量为<span class="number">22</span></span><br><span class="line">Thread[Thread-<span class="number">6</span>,<span class="number">5</span>,main]已经消费了<span class="number">1</span>个产品,现在库存量为<span class="number">21</span></span><br><span class="line">Thread[Thread-<span class="number">6</span>,<span class="number">5</span>,main]已经消费了<span class="number">1</span>个产品,现在库存量为<span class="number">20</span></span><br><span class="line">Thread[Thread-<span class="number">6</span>,<span class="number">5</span>,main]已经消费了<span class="number">1</span>个产品,现在库存量为<span class="number">19</span></span><br><span class="line">Thread[Thread-<span class="number">6</span>,<span class="number">5</span>,main]已经消费了<span class="number">1</span>个产品,现在库存量为<span class="number">18</span></span><br><span class="line">Thread[Thread-<span class="number">6</span>,<span class="number">5</span>,main]已经消费了<span class="number">1</span>个产品,现在库存量为<span class="number">17</span></span><br><span class="line">Thread[Thread-<span class="number">6</span>,<span class="number">5</span>,main]已经消费了<span class="number">1</span>个产品,现在库存量为<span class="number">16</span></span><br><span class="line">Thread[Thread-<span class="number">6</span>,<span class="number">5</span>,main]已经消费了<span class="number">1</span>个产品,现在库存量为<span class="number">15</span></span><br><span class="line">Thread[Thread-<span class="number">6</span>,<span class="number">5</span>,main]已经消费了<span class="number">1</span>个产品,现在库存量为<span class="number">14</span></span><br><span class="line">Thread[Thread-<span class="number">6</span>,<span class="number">5</span>,main]已经消费了<span class="number">1</span>个产品,现在库存量为<span class="number">13</span></span><br><span class="line">Thread[Thread-<span class="number">6</span>,<span class="number">5</span>,main]已经消费了<span class="number">1</span>个产品,现在库存量为<span class="number">12</span></span><br><span class="line">Thread[Thread-<span class="number">6</span>,<span class="number">5</span>,main]已经消费了<span class="number">1</span>个产品,现在库存量为<span class="number">11</span></span><br><span class="line">Thread[Thread-<span class="number">6</span>,<span class="number">5</span>,main]已经消费了<span class="number">1</span>个产品,现在库存量为<span class="number">10</span></span><br><span class="line">Thread[Thread-<span class="number">6</span>,<span class="number">5</span>,main]已经消费了<span class="number">1</span>个产品,现在库存量为<span class="number">9</span></span><br><span class="line">Thread[Thread-<span class="number">6</span>,<span class="number">5</span>,main]已经消费了<span class="number">1</span>个产品,现在库存量为<span class="number">8</span></span><br><span class="line">Thread[Thread-<span class="number">6</span>,<span class="number">5</span>,main]已经消费了<span class="number">1</span>个产品,现在库存量为<span class="number">7</span></span><br><span class="line">Thread[Thread-<span class="number">6</span>,<span class="number">5</span>,main]已经消费了<span class="number">1</span>个产品,现在库存量为<span class="number">6</span></span><br><span class="line">Thread[Thread-<span class="number">6</span>,<span class="number">5</span>,main]已经消费了<span class="number">1</span>个产品,现在库存量为<span class="number">5</span></span><br><span class="line">Thread[Thread-<span class="number">6</span>,<span class="number">5</span>,main]已经消费了<span class="number">1</span>个产品,现在库存量为<span class="number">4</span></span><br><span class="line">Thread[Thread-<span class="number">6</span>,<span class="number">5</span>,main]已经消费了<span class="number">1</span>个产品,现在库存量为<span class="number">3</span></span><br><span class="line">Thread[Thread-<span class="number">6</span>,<span class="number">5</span>,main]已经消费了<span class="number">1</span>个产品,现在库存量为<span class="number">2</span></span><br><span class="line">Thread[Thread-<span class="number">6</span>,<span class="number">5</span>,main]已经消费了<span class="number">1</span>个产品,现在库存量为<span class="number">1</span></span><br><span class="line">Thread[Thread-<span class="number">6</span>,<span class="number">5</span>,main]已经消费了<span class="number">1</span>个产品,现在库存量为<span class="number">0</span></span><br><span class="line">Thread[Thread-<span class="number">5</span>,<span class="number">5</span>,main]此时库存量为<span class="number">0</span>,不能进行消费操作</span><br><span class="line">Thread[Thread-<span class="number">4</span>,<span class="number">5</span>,main]此时库存量为<span class="number">0</span>,不能进行消费操作</span><br><span class="line">Thread[Thread-<span class="number">1</span>,<span class="number">5</span>,main]已经生产了<span class="number">1</span>个产品,现在库存量为<span class="number">1</span></span><br><span class="line">Thread[Thread-<span class="number">1</span>,<span class="number">5</span>,main]已经生产了<span class="number">1</span>个产品,现在库存量为<span class="number">2</span></span><br><span class="line">Thread[Thread-<span class="number">1</span>,<span class="number">5</span>,main]已经生产了<span class="number">1</span>个产品,现在库存量为<span class="number">3</span></span><br><span class="line">Thread[Thread-<span class="number">1</span>,<span class="number">5</span>,main]已经生产了<span class="number">1</span>个产品,现在库存量为<span class="number">4</span></span><br><span class="line">Thread[Thread-<span class="number">1</span>,<span class="number">5</span>,main]已经生产了<span class="number">1</span>个产品,现在库存量为<span class="number">5</span></span><br><span class="line">Thread[Thread-<span class="number">1</span>,<span class="number">5</span>,main]已经生产了<span class="number">1</span>个产品,现在库存量为<span class="number">6</span></span><br><span class="line">Thread[Thread-<span class="number">1</span>,<span class="number">5</span>,main]已经生产了<span class="number">1</span>个产品,现在库存量为<span class="number">7</span></span><br><span class="line">Thread[Thread-<span class="number">1</span>,<span class="number">5</span>,main]已经生产了<span class="number">1</span>个产品,现在库存量为<span class="number">8</span></span><br><span class="line">Thread[Thread-<span class="number">1</span>,<span class="number">5</span>,main]已经生产了<span class="number">1</span>个产品,现在库存量为<span class="number">9</span></span><br><span class="line">Thread[Thread-<span class="number">1</span>,<span class="number">5</span>,main]已经生产了<span class="number">1</span>个产品,现在库存量为<span class="number">10</span></span><br><span class="line">Thread[Thread-<span class="number">4</span>,<span class="number">5</span>,main]已经消费了<span class="number">1</span>个产品,现在库存量为<span class="number">9</span></span><br><span class="line">Thread[Thread-<span class="number">4</span>,<span class="number">5</span>,main]已经消费了<span class="number">1</span>个产品,现在库存量为<span class="number">8</span></span><br><span class="line">Thread[Thread-<span class="number">4</span>,<span class="number">5</span>,main]已经消费了<span class="number">1</span>个产品,现在库存量为<span class="number">7</span></span><br><span class="line">Thread[Thread-<span class="number">4</span>,<span class="number">5</span>,main]已经消费了<span class="number">1</span>个产品,现在库存量为<span class="number">6</span></span><br><span class="line">Thread[Thread-<span class="number">4</span>,<span class="number">5</span>,main]已经消费了<span class="number">1</span>个产品,现在库存量为<span class="number">5</span></span><br><span class="line">Thread[Thread-<span class="number">4</span>,<span class="number">5</span>,main]已经消费了<span class="number">1</span>个产品,现在库存量为<span class="number">4</span></span><br><span class="line">Thread[Thread-<span class="number">4</span>,<span class="number">5</span>,main]已经消费了<span class="number">1</span>个产品,现在库存量为<span class="number">3</span></span><br><span class="line">Thread[Thread-<span class="number">4</span>,<span class="number">5</span>,main]已经消费了<span class="number">1</span>个产品,现在库存量为<span class="number">2</span></span><br><span class="line">Thread[Thread-<span class="number">4</span>,<span class="number">5</span>,main]已经消费了<span class="number">1</span>个产品,现在库存量为<span class="number">1</span></span><br><span class="line">Thread[Thread-<span class="number">4</span>,<span class="number">5</span>,main]已经消费了<span class="number">1</span>个产品,现在库存量为<span class="number">0</span></span><br><span class="line">Thread[Thread-<span class="number">4</span>,<span class="number">5</span>,main]此时库存量为<span class="number">0</span>,不能进行消费操作</span><br><span class="line">Thread[Thread-<span class="number">5</span>,<span class="number">5</span>,main]此时库存量为<span class="number">0</span>,不能进行消费操作</span><br></pre></td></tr></table></figure></p><p>第二种（LinkedBlockingQueue ）</p><p>只修改Storage其他不变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Storage</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SIZE = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> LinkedBlockingQueue&lt;Object&gt; list = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">100</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(list.size()==MAX_SIZE)&#123;</span><br><span class="line">               System.out.println(Thread.currentThread ()+<span class="string">"此时库存量:"</span>+MAX_SIZE+<span class="string">",容量已满,不能进行生产操作"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">               <span class="keyword">try</span>&#123;</span><br><span class="line">                   list.put(<span class="keyword">new</span> Object());</span><br><span class="line"></span><br><span class="line">               &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               System.out.println(Thread.currentThread ()+<span class="string">"已经生产了1个商品,此时容量为:"</span>+list.size());</span><br><span class="line">           &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(list.size()==<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread ()+<span class="string">"此时库存量:0,不能进行消费操作"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    list.take();</span><br><span class="line"></span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread ()+<span class="string">"已经消费了1个商品,此时容量为:"</span>+list.size());</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMAX_SIZE</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> MAX_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LinkedBlockingQueue&lt;Object&gt; <span class="title">getList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setList</span><span class="params">(LinkedBlockingQueue&lt;Object&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ps：用LinkedBlockingQueue最后结果打印的时候可能和想象的不一致，是因为如果此时容量已满，在执行put操作时候，内部会调用await()方法，释放了线程的执行权，然后消费者线程拿到执行权调用take()方法，当消费完毕后通知生产者时候会调用signal()方法， 但是这个时候消费者或者还没有打印完我们定义的语句，然后生产者生产又开始打印生产语句，导致输出语句不匹配，所以这个是正常的。</strong></p><pre><code>Thanks!</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里暂时介绍两种。&lt;br&gt;第一种是wait()—–notifyAll()&lt;br&gt;第二种是用到了LinkedBlockingQueue(原理同上，可以点源码详细学习)&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://jantc.cn/categories/java/"/>
    
    
      <category term="设计模式" scheme="http://jantc.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis-generator 代码生成工具</title>
    <link href="http://jantc.cn/2017/04/15/MyBatis-generator-%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7/"/>
    <id>http://jantc.cn/2017/04/15/MyBatis-generator-代码生成工具/</id>
    <published>2017-04-15T10:21:47.000Z</published>
    <updated>2020-03-23T09:10:50.363Z</updated>
    
    <content type="html"><![CDATA[<p>现在做很多小项目的时候，用到MyBatis，每次都要自己去写每个方法对应的xml把，很多小伙伴对MyBatis的xml书写不是很熟悉的，就会犯很多错误。现在有了这个工具就再也不用担心咯。<br>本工具可以帮你自动生成 dao层、entity层、以及dao对应mybatis所需要的xml文件（mapping层）。我们只需要在数据库建一张表然后按照下面稍稍改动一下，就能生成相应的代码。</p><a id="more"></a><p>剩下的开发重心就只需要放在controller中去实现我们真正的业务逻辑了。如果需要条件查询。那么也可以自己在dao层里面新增方法，然后按照参照xml中的格式直接在对应的xml文件中写个sql语句就好了。</p><p><a href="https://pan.baidu.com/s/1miqMdde" target="_blank" rel="noopener">工具下载链接</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;</span><br><span class="line">&lt;generatorConfiguration&gt;</span><br><span class="line">    &lt;!-- 数据库驱动包位置 --&gt;</span><br><span class="line">    &lt;classPathEntry location=&quot;D:\generator\mysql-connector-java-5.1.34.jar&quot; /&gt; </span><br><span class="line">    &lt;context id=&quot;DB2Tables&quot; targetRuntime=&quot;MyBatis3&quot;&gt;</span><br><span class="line">        &lt;commentGenerator&gt;</span><br><span class="line">            &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot; /&gt;</span><br><span class="line">        &lt;/commentGenerator&gt;</span><br><span class="line">        &lt;!-- 数据库链接URL、用户名、密码 --&gt;</span><br><span class="line">         &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/a?characterEncoding=utf8&quot; userId=&quot;root&quot; password=&quot;root&quot;&gt; </span><br><span class="line">        &lt;/jdbcConnection&gt;</span><br><span class="line">        &lt;javaTypeResolver&gt;</span><br><span class="line">            &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt;</span><br><span class="line">        &lt;/javaTypeResolver&gt;</span><br><span class="line">        &lt;!-- 生成模型的包名和位置 --&gt;</span><br><span class="line">        &lt;javaModelGenerator targetPackage=&quot;zjc.model&quot; targetProject=&quot;D:\generator\src&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt;</span><br><span class="line">            &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt;</span><br><span class="line">        &lt;/javaModelGenerator&gt;</span><br><span class="line">        &lt;!-- 生成的映射文件包名和位置 --&gt;</span><br><span class="line">        &lt;sqlMapGenerator targetPackage=&quot;zjc.mapping&quot; targetProject=&quot;D:\generator\src&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt;</span><br><span class="line">        &lt;/sqlMapGenerator&gt;</span><br><span class="line">        &lt;!-- 生成DAO的包名和位置 --&gt;</span><br><span class="line">        &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;zjc.dao&quot; targetProject=&quot;D:\generator\src&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt;</span><br><span class="line">        &lt;/javaClientGenerator&gt;</span><br><span class="line">        &lt;!-- 要生成那些表(更改tableName和domainObjectName就可以) --&gt;</span><br><span class="line">        &lt;table tableName=&quot;stu&quot; domainObjectName=&quot;Stu&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot; /&gt;</span><br><span class="line">        &lt;!-- &lt;table tableName=&quot;course_info&quot; domainObjectName=&quot;CourseInfo&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot; /&gt;</span><br><span class="line">        &lt;table tableName=&quot;course_user_info&quot; domainObjectName=&quot;CourseUserInfo&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot; /&gt; --&gt;</span><br><span class="line">    &lt;/context&gt;</span><br><span class="line">&lt;/generatorConfiguration&gt;</span><br></pre></td></tr></table></figure><p>这是文件目录<br><img src="http://ooes75dyq.bkt.clouddn.com/20170411100603601.png" alt="这是文件目录"></p><p>按上述配置编辑好generator.xml 然后在此文件夹下 shift+鼠标右键<br><img src="http://ooes75dyq.bkt.clouddn.com/20170412150228376.png" alt></p><p>输入Java -jar mybatis-generator-core-1.3.2.jar -configfile generator.xml -overwrite<br><img src="http://ooes75dyq.bkt.clouddn.com/20170412150300260.png" alt></p><p>看到Success就表示生成成功了，然后去生成的文件夹下查看<br><img src="http://ooes75dyq.bkt.clouddn.com/20170412150350152.png" alt></p><pre><code>Thanks！</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在做很多小项目的时候，用到MyBatis，每次都要自己去写每个方法对应的xml把，很多小伙伴对MyBatis的xml书写不是很熟悉的，就会犯很多错误。现在有了这个工具就再也不用担心咯。&lt;br&gt;本工具可以帮你自动生成 dao层、entity层、以及dao对应mybatis所需要的xml文件（mapping层）。我们只需要在数据库建一张表然后按照下面稍稍改动一下，就能生成相应的代码。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://jantc.cn/categories/java/"/>
    
    
      <category term="mybatis" scheme="http://jantc.cn/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>MySql获取插入记录自增主键ID值</title>
    <link href="http://jantc.cn/2017/04/15/MySql%E8%8E%B7%E5%8F%96%E6%8F%92%E5%85%A5%E8%AE%B0%E5%BD%95%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AEID%E5%80%BC/"/>
    <id>http://jantc.cn/2017/04/15/MySql获取插入记录自增主键ID值/</id>
    <published>2017-04-15T10:17:03.000Z</published>
    <updated>2020-03-23T09:10:50.365Z</updated>
    
    <content type="html"><![CDATA[<p>现在这种场景偏多，获取的方式也很多。像MyBatis和hibernate都有方式去获取该值。</p><p>现在简单讲讲MyBatis是获取插入记录自增主键ID值的。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stu</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StuDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertStu</span><span class="params">(Stu stu)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//mybatis dao.xml</span></span><br><span class="line">&lt;mapper namespace=<span class="string">"org.zjc.dao.StuDao"</span>&gt;</span><br><span class="line">    &lt;insert id=<span class="string">"insertStu"</span> parameterType=<span class="string">"org.zjc.entity.Stu"</span> useGeneratedKeys=<span class="string">"true"</span> keyProperty=<span class="string">"id"</span>&gt;</span><br><span class="line">          <span class="function">insert into <span class="title">stu</span><span class="params">(Name)</span> <span class="title">values</span> <span class="params">(#&#123;name,jdbcType=VARCHAR&#125;)</span></span></span><br><span class="line"><span class="function">    &lt;/insert&gt;</span></span><br><span class="line"><span class="function">&lt;/mapper&gt;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//JUnit4</span></span></span><br><span class="line"><span class="function"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestinsertStu</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Stu stu = <span class="keyword">new</span> Stu();</span><br><span class="line">        stu.setName(<span class="string">"吕布"</span>);</span><br><span class="line">        <span class="keyword">int</span> i = stuDao.insertStu(stu);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        System.out.println(stu.getId());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里的i代表影响的行数。<br>执行完stuDao.insertStu(stu)就会将本次插入的记录的自增主键ID赋值到stu对象的id中。</p><p>你可以理解stuDao.insertStu(stu)干了这两件事：<br>1.<font color="red">先往表中插入了记录<br>2.调用了stu.setId方法</font> </p><p>useGeneratedKeys默认为false。该字段代表设置是否使用JDBC的getGenereatedKeys方法获取主键并赋值到keyProperty设置的领域模型属性中。在这里我们设置字段值为true，然后设置keyProperty的值。keyProperty的值注意必须和实体类的主键名一致，（注意不是数据库表的自增主键字段名）。</p><p>如果没有用MyBatis。那么直接调用getGeneratedKeys()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Connection conn = ;</span><br><span class="line">        Serializable ret = <span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement state = .;</span><br><span class="line">        ResultSet rs=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            state.executeUpdate();</span><br><span class="line">            rs = state.getGeneratedKeys();</span><br><span class="line">            <span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">                ret = (Serializable) rs.getObject(<span class="number">1</span>);</span><br><span class="line">            &#125;       </span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br></pre></td></tr></table></figure><pre><code>Thanks!</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在这种场景偏多，获取的方式也很多。像MyBatis和hibernate都有方式去获取该值。&lt;/p&gt;
&lt;p&gt;现在简单讲讲MyBatis是获取插入记录自增主键ID值的。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://jantc.cn/categories/java/"/>
    
    
      <category term="mysql" scheme="http://jantc.cn/tags/mysql/"/>
    
  </entry>
  
</feed>
